
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Mimir Edge Enforcement - Comprehensive Documentation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 40px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        h3 {
            color: #7f8c8d;
            margin-top: 25px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        li {
            margin-bottom: 5px;
        }
        p {
            margin-bottom: 15px;
        }
        .toc {
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        .toc h2 {
            border-bottom: none;
            margin-top: 0;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin-bottom: 8px;
        }
        .toc a {
            text-decoration: none;
            color: #2c3e50;
        }
        .toc a:hover {
            color: #3498db;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
    </style>
</head>
<body>
    <h1>Mimir Edge Enforcement - Comprehensive Documentation</h1></p><p><h2>Table of Contents</h2></p><p><h3>üìã Executive Summary</h3>
<li>[Executive Summary](#executive-summary)</li>
<li>[Business Value](#business-value)</li>
<li>[Problem Statement](#problem-statement)</li></p><p><h3>üèóÔ∏è Architecture & Design</h3>
<li>[System Architecture](#system-architecture)</li>
<li>[Component Architecture](#component-architecture)</li>
<li>[Data Flow Diagrams](#data-flow-diagrams)</li>
<li>[Network Architecture](#network-architecture)</li></p><p><h3>üîß Components Deep Dive</h3>
<li>[Rate Limit Service (RLS)](#rate-limit-service-rls)</li>
<li>[Envoy Proxy](#envoy-proxy)</li>
<li>[Overrides-Sync Controller](#overrides-sync-controller)</li>
<li>[Admin UI](#admin-ui)</li></p><p><h3>‚ú® Features & Capabilities</h3>
<li>[Core Features](#core-features)</li>
<li>[Advanced Features](#advanced-features)</li>
<li>[Selective Traffic Routing](#selective-traffic-routing)</li>
<li>[Time-Based Aggregation](#time-based-aggregation)</li></p><p><h3>üöÄ Deployment & Operations</h3>
<li>[Deployment Strategy](#deployment-strategy)</li>
<li>[Production Deployment](#production-deployment)</li>
<li>[Scaling Strategy](#scaling-strategy)</li>
<li>[Rollback Procedures](#rollback-procedures)</li></p><p><h3>üìä Monitoring & Observability</h3>
<li>[Monitoring Strategy](#monitoring-strategy)</li>
<li>[Metrics & Dashboards](#metrics--dashboards)</li>
<li>[Alerting Strategy](#alerting-strategy)</li>
<li>[Logging Strategy](#logging-strategy)</li></p><p><h3>üîí Security & Compliance</h3>
<li>[Security Architecture](#security-architecture)</li>
<li>[Network Security](#network-security)</li>
<li>[Container Security](#container-security)</li>
<li>[Compliance](#compliance)</li></p><p><h3>‚ö° Performance & Scalability</h3>
<li>[Performance Characteristics](#performance-characteristics)</li>
<li>[Scalability Analysis](#scalability-analysis)</li>
<li>[Bottleneck Analysis](#bottleneck-analysis)</li>
<li>[Load Testing Results](#load-testing-results)</li></p><p><h3>üõ†Ô∏è API Reference</h3>
<li>[API Overview](#api-overview)</li>
<li>[REST API Reference](#rest-api-reference)</li>
<li>[gRPC API Reference](#grpc-api-reference)</li>
<li>[API Examples](#api-examples)</li></p><p><h3>üíª Code Examples</h3>
<li>[Backend Code Examples](#backend-code-examples)</li>
<li>[Frontend Code Examples](#frontend-code-examples)</li>
<li>[Configuration Examples](#configuration-examples)</li>
<li>[Kubernetes Manifests](#kubernetes-manifests)</li></p><p><h3>üîß Troubleshooting</h3>
<li>[Common Issues](#common-issues)</li>
<li>[Debug Procedures](#debug-procedures)</li>
<li>[Performance Troubleshooting](#performance-troubleshooting)</li>
<li>[Recovery Procedures](#recovery-procedures)</li></p><p><h3>üöÄ Future Enhancements</h3>
<li>[Roadmap](#roadmap)</li>
<li>[Feature Requests](#feature-requests)</li>
<li>[Technical Debt](#technical-debt)</li>
<li>[Architecture Evolution](#architecture-evolution)</li></p><p>---</p><p><h2>Document Information</h2></p><p><li><strong>Version</strong>: 1.0</li>
<li><strong>Last Updated</strong>: January 2024</li>
<li><strong>Maintainer</strong>: Development Team</li>
<li><strong>Review Cycle</strong>: Quarterly</li>
<li><strong>Update Process</strong>: Pull request workflow</li></p><p>---</p><p>
<h2>Executive Summary</h2></p><p>
<h2>Overview</h2></p><p><strong>Mimir Edge Enforcement</strong> is a production-ready, cloud-agnostic Kubernetes solution that enforces Mimir tenant ingestion limits at the edge using Envoy, a Rate/Authorization Service (RLS), an overrides-sync controller, and a React Admin UI.</p><p><h2>Business Problem</h2></p><p>Traditional Mimir deployments lack tenant-level enforcement at the edge, leading to:
<li><strong>Resource Exhaustion</strong>: Abusive tenants consuming disproportionate resources</li>
<li><strong>Unfair Resource Allocation</strong>: No mechanism to enforce contractual limits</li>
<li><strong>Operational Challenges</strong>: Difficulty in monitoring and controlling tenant behavior</li>
<li><strong>Cost Overruns</strong>: Uncontrolled resource consumption impacting infrastructure costs</li></p><p><h2>Solution Overview</h2></p><p><h3>High-Level Architecture</h3>
<pre><code>Alloy ‚Üí NGINX ‚Üí Envoy ‚Üí Mimir Distributor
              ‚Üì
           RLS (ext_authz + ratelimit)
              ‚Üì
        overrides-sync (watches ConfigMap)
              ‚Üì
         Admin UI (monitoring & controls)
</code></pre></p><p><h3>Key Components</h3>
<li><strong>Rate Limit Service (RLS)</strong>: Core enforcement engine with gRPC and HTTP APIs</li>
<li><strong>Envoy Proxy</strong>: Edge proxy with external authorization and rate limiting filters</li>
<li><strong>Overrides-Sync Controller</strong>: Kubernetes controller for dynamic limit management</li>
<li><strong>Admin UI</strong>: React-based web interface for monitoring and management</li></p><p><h2>Business Value</h2></p><p><h3>üéØ <strong>Cost Control</strong></h3>
<li>Prevents tenant abuse and resource exhaustion</li>
<li>Enforces fair resource allocation based on contracts</li>
<li>Reduces infrastructure costs through controlled consumption</li></p><p><h3>üõ°Ô∏è <strong>Service Protection</strong></h3>
<li>Ensures system stability under high load</li>
<li>Protects against tenant misbehavior</li>
<li>Maintains service quality for all tenants</li></p><p><h3>üìä <strong>Operational Excellence</strong></h3>
<li>Real-time monitoring and alerting</li>
<li>Comprehensive dashboards and metrics</li>
<li>Proactive issue detection and resolution</li></p><p><h3>üîÑ <strong>Zero Disruption</strong></h3>
<li>Bump-in-the-wire deployment</li>
<li>No client application changes required</li>
<li>Instant rollback capability</li></p><p><h2>Technical Highlights</h2></p><p><h3><strong>Zero Client Changes</strong></h3>
<li>Deployed behind existing NGINX infrastructure</li>
<li>No application modifications required</li>
<li>Instant rollback via NGINX reload</li></p><p><h3><strong>Accurate Enforcement</strong></h3>
<li>Real-time tenant limit enforcement</li>
<li>Protobuf parsing for precise metrics</li>
<li>Token bucket algorithm for rate limiting</li></p><p><h3><strong>Observability-First</strong></h3>
<li>Comprehensive Prometheus metrics</li>
<li>Structured JSON logging</li>
<li>Real-time dashboards and alerting</li></p><p><h3><strong>Production-Ready</strong></h3>
<li>High availability with multiple replicas</li>
<li>Horizontal scaling with auto-scaling</li>
<li>Security hardening and RBAC</li></p><p><h2>Deployment Strategy</h2></p><p><h3><strong>Phase 1: Mirror Mode (Zero Impact)</strong></h3>
<li>Shadow traffic to validate system</li>
<li>No user-visible impact</li>
<li>Metrics and monitoring validation</li></p><p><h3><strong>Phase 2: Canary Mode (Gradual Rollout)</strong></h3>
<li>Weighted traffic splitting (1% ‚Üí 100%)</li>
<li>Controlled rollout with monitoring</li>
<li>Performance validation</li></p><p><h3><strong>Phase 3: Full Mode (Complete Deployment)</strong></h3>
<li>All traffic through enforcement</li>
<li>Full tenant limit enforcement</li>
<li>Production monitoring and alerting</li></p><p><h2>Performance Characteristics</h2></p><p><h3><strong>Latency Impact</strong></h3>
<li>Total overhead: ~2-8ms per request</li>
<li>ext_authz: ~1-5ms additional latency</li>
<li>Body parsing: ~0.5-2ms for typical requests</li></p><p><h3><strong>Throughput</strong></h3>
<li>RLS: 10,000+ requests/second per instance</li>
<li>Envoy: 50,000+ requests/second per instance</li>
<li>Horizontal scaling: 10-40 replicas per service</li></p><p><h3><strong>Resource Usage</strong></h3>
<li>Memory: ~100-500MB per RLS instance</li>
<li>CPU: ~0.1-1 CPU core per RLS instance</li>
<li>Network: Minimal overhead for control plane</li></p><p><h2>Success Metrics</h2></p><p><h3><strong>Operational Metrics</strong></h3>
<li>99.9% system uptime</li>
<li><10ms average latency impact</li>
<li>Zero client-side changes required</li>
<li><5 minute rollback capability</li></p><p><h3><strong>Business Metrics</strong></h3>
<li>100% tenant limit enforcement</li>
<li>50% reduction in resource abuse</li>
<li>30% improvement in system stability</li>
<li>25% reduction in infrastructure costs</li></p><p><h2>Risk Mitigation</h2></p><p><h3><strong>Technical Risks</strong></h3>
<li><strong>Service Failure</strong>: Configurable failure modes (allow/deny)</li>
<li><strong>Performance Impact</strong>: Comprehensive load testing and monitoring</li>
<li><strong>Data Loss</strong>: In-memory state with optional Redis persistence</li></p><p><h3><strong>Operational Risks</strong></h3>
<li><strong>Rollout Issues</strong>: Gradual deployment with rollback capability</li>
<li><strong>Monitoring Gaps</strong>: Comprehensive observability and alerting</li>
<li><strong>Security Concerns</strong>: Security hardening and RBAC implementation</li></p><p><h2>Investment Summary</h2></p><p><h3><strong>Development Effort</strong></h3>
<li><strong>Phase 1</strong>: 2-3 months (Core development)</li>
<li><strong>Phase 2</strong>: 1-2 months (Testing and refinement)</li>
<li><strong>Phase 3</strong>: 1 month (Production deployment)</li></p><p><h3><strong>Infrastructure Costs</strong></h3>
<li><strong>Development</strong>: Minimal (uses existing infrastructure)</li>
<li><strong>Production</strong>: ~$5K-10K/month for high-scale deployment</li>
<li><strong>ROI</strong>: 3-6 month payback period</li></p><p><h3><strong>Operational Costs</strong></h3>
<li><strong>Maintenance</strong>: 0.5 FTE for ongoing operations</li>
<li><strong>Monitoring</strong>: Integrated with existing monitoring stack</li>
<li><strong>Support</strong>: Self-service with comprehensive documentation</li></p><p><h2>Competitive Advantages</h2></p><p><h3><strong>Technical Advantages</strong></h3>
<li>Zero client changes required</li>
<li>Real-time enforcement with sub-10ms latency</li>
<li>Comprehensive observability and monitoring</li>
<li>Production-ready with enterprise features</li></p><p><h3><strong>Operational Advantages</strong></h3>
<li>Gradual deployment with zero risk</li>
<li>Instant rollback capability</li>
<li>Self-service management interface</li>
<li>Comprehensive troubleshooting tools</li></p><p><h3><strong>Business Advantages</strong></h3>
<li>Immediate cost savings through resource control</li>
<li>Improved system stability and reliability</li>
<li>Enhanced tenant experience and fairness</li>
<li>Reduced operational overhead</li></p><p><h2>Next Steps</h2></p><p><h3><strong>Immediate Actions (Next 30 Days)</strong></h3>
<li><strong>Architecture Review</strong>: Technical deep-dive with architecture team</li>
<li><strong>Proof of Concept</strong>: Deploy in development environment</li>
<li><strong>Performance Testing</strong>: Validate performance characteristics</li>
<li><strong>Security Review</strong>: Security assessment and hardening</li></p><p><h3><strong>Short-term Goals (Next 90 Days)</strong></h3>
<li><strong>Production Deployment</strong>: Phase 1 mirror mode deployment</li>
<li><strong>Monitoring Setup</strong>: Comprehensive monitoring and alerting</li>
<li><strong>Team Training</strong>: Operations team training and documentation</li>
<li><strong>Performance Optimization</strong>: Fine-tune based on real-world usage</li></p><p><h3><strong>Long-term Vision (Next 6-12 Months)</strong></h3>
<li><strong>Full Production</strong>: Complete deployment across all environments</li>
<li><strong>Feature Enhancement</strong>: Advanced features and capabilities</li>
<li><strong>Scale Optimization</strong>: Performance and scalability improvements</li>
<li><strong>Integration Expansion</strong>: Additional integrations and use cases</li></p><p><h2>Conclusion</h2></p><p>Mimir Edge Enforcement provides a comprehensive, production-ready solution for enforcing tenant ingestion limits at the edge. With its zero-client-change deployment model, comprehensive monitoring, and safe rollout strategies, it enables organizations to protect their Mimir infrastructure while maintaining operational excellence.</p><p>The solution delivers immediate business value through cost control, service protection, and operational excellence, with a clear path to production deployment and long-term success.</p><p>---</p><p><strong>Recommendation</strong>: Proceed with architecture review and proof of concept deployment to validate the solution in our environment.</p><p><strong>Contact</strong>: Development Team  
<strong>Next Review</strong>: Architecture Review Meeting</p><p>---</p><p>
<h2>Business Value</h2></p><p>
<h2>Executive Summary</h2></p><p>The Mimir Edge Enforcement system delivers significant business value through cost control, service protection, operational excellence, and competitive advantage. This document outlines the quantifiable benefits and return on investment (ROI) for implementing the solution.</p><p><h2>Business Problem & Impact</h2></p><p><h3>Current Challenges</h3></p><p>#### Resource Exhaustion
<li><strong>Problem</strong>: Abusive tenants consuming disproportionate infrastructure resources</li>
<li><strong>Impact</strong>: 30-50% of infrastructure costs wasted on resource abuse</li>
<li><strong>Risk</strong>: Service degradation for legitimate tenants</li></p><p>#### Unfair Resource Allocation
<li><strong>Problem</strong>: No mechanism to enforce contractual limits</li>
<li><strong>Impact</strong>: Inability to monetize resource usage effectively</li>
<li><strong>Risk</strong>: Revenue leakage and customer dissatisfaction</li></p><p>#### Operational Overhead
<li><strong>Problem</strong>: Manual monitoring and intervention required</li>
<li><strong>Impact</strong>: 20-30% of operations team time spent on resource management</li>
<li><strong>Risk</strong>: Increased operational costs and reduced efficiency</li></p><p>#### Compliance Risk
<li><strong>Problem</strong>: No audit trail for resource usage</li>
<li><strong>Impact</strong>: Difficulty in enforcing SLAs and contracts</li>
<li><strong>Risk</strong>: Legal and compliance issues</li></p><p><h2>Solution Benefits</h2></p><p><h3>üéØ Cost Control & Revenue Protection</h3></p><p>#### Infrastructure Cost Reduction
<li><strong>Resource Abuse Prevention</strong>: 40-60% reduction in wasted infrastructure costs</li>
<li><strong>Fair Resource Allocation</strong>: Enables per-tenant resource billing</li>
<li><strong>Predictable Costs</strong>: Better capacity planning and budgeting</li></p><p>#### Revenue Protection
<li><strong>Contractual Enforcement</strong>: Ensures tenants pay for actual usage</li>
<li><strong>Overage Billing</strong>: Enables billing for resource overages</li>
<li><strong>Revenue Recovery</strong>: 15-25% increase in revenue through proper billing</li></p><p>#### Quantified Savings
<pre><code>Annual Infrastructure Cost: $2,000,000
Resource Abuse Reduction: 40% = $800,000 savings
Revenue Recovery: 20% = $400,000 additional revenue
Total Annual Benefit: $1,200,000
</code></pre></p><p><h3>üõ°Ô∏è Service Protection & Reliability</h3></p><p>#### System Stability
<li><strong>Prevents Resource Exhaustion</strong>: Ensures system stability under load</li>
<li><strong>Fair Resource Distribution</strong>: All tenants get their fair share</li>
<li><strong>Predictable Performance</strong>: Consistent service quality</li></p><p>#### SLA Compliance
<li><strong>Enforced Limits</strong>: Guarantees resource availability</li>
<li><strong>Performance Monitoring</strong>: Real-time performance tracking</li>
<li><strong>Proactive Alerts</strong>: Early warning of potential issues</li></p><p>#### Quantified Benefits
<pre><code>System Uptime Improvement: 99.9% ‚Üí 99.95% = 0.05% improvement
Customer Satisfaction: 85% ‚Üí 95% = 10% improvement
Support Ticket Reduction: 30% reduction in resource-related issues
</code></pre></p><p><h3>üìä Operational Excellence</h3></p><p>#### Automation & Efficiency
<li><strong>Zero Manual Intervention</strong>: Automated enforcement and monitoring</li>
<li><strong>Real-time Visibility</strong>: Comprehensive dashboards and metrics</li>
<li><strong>Proactive Management</strong>: Early detection and resolution of issues</li></p><p>#### Team Productivity
<li><strong>Reduced Operational Overhead</strong>: 60-80% reduction in manual monitoring</li>
<li><strong>Focused Engineering</strong>: Teams can focus on core product development</li>
<li><strong>Improved Response Time</strong>: Faster issue detection and resolution</li></p><p>#### Quantified Benefits
<pre><code>Operations Team Size: 5 engineers
Time Saved per Engineer: 20 hours/week
Annual Time Savings: 5 √ó 20 √ó 52 = 5,200 hours
Cost Savings: 5,200 √ó $100/hour = $520,000
</code></pre></p><p><h3>üîÑ Zero Disruption Deployment</h3></p><p>#### Risk Mitigation
<li><strong>Zero Client Changes</strong>: No application modifications required</li>
<li><strong>Instant Rollback</strong>: 5-minute emergency rollback capability</li>
<li><strong>Gradual Rollout</strong>: Phased deployment with monitoring</li></p><p>#### Business Continuity
<li><strong>No Service Interruption</strong>: Zero downtime deployment</li>
<li><strong>Continuous Monitoring</strong>: Real-time validation during rollout</li>
<li><strong>Risk-Free Testing</strong>: Shadow mode validation</li></p><p>#### Quantified Benefits
<pre><code>Deployment Risk Reduction: 90% reduction in deployment risks
Rollback Time: 5 minutes vs. traditional 2-4 hours
Testing Confidence: 100% validation before production impact
</code></pre></p><p><h2>Return on Investment (ROI)</h2></p><p><h3>Investment Costs</h3></p><p>#### Development Costs
<li><strong>Phase 1 (Core Development)</strong>: 2-3 months √ó 3 engineers = 18-27 person-months</li>
<li><strong>Phase 2 (Testing & Refinement)</strong>: 1-2 months √ó 2 engineers = 2-4 person-months</li>
<li><strong>Phase 3 (Production Deployment)</strong>: 1 month √ó 2 engineers = 2 person-months</li>
<li><strong>Total Development</strong>: 22-33 person-months √ó $15,000/month = $330,000 - $495,000</li></p><p>#### Infrastructure Costs
<li><strong>Development Environment</strong>: $2,000/month √ó 3 months = $6,000</li>
<li><strong>Staging Environment</strong>: $5,000/month √ó 2 months = $10,000</li>
<li><strong>Production Environment</strong>: $8,000/month √ó 12 months = $96,000</li>
<li><strong>Total Infrastructure</strong>: $112,000/year</li></p><p>#### Operational Costs
<li><strong>Ongoing Maintenance</strong>: 0.5 FTE √ó $120,000/year = $60,000</li>
<li><strong>Monitoring & Support</strong>: $24,000/year</li>
<li><strong>Total Operational</strong>: $84,000/year</li></p><p>#### Total Investment
<pre><code>Development: $412,500 (average)
Infrastructure: $112,000
Operations: $84,000
Total First Year: $608,500
Annual Ongoing: $196,000
</code></pre></p><p><h3>Return on Investment</h3></p><p>#### First Year ROI
<pre><code>Total Investment: $608,500
Annual Benefits: $1,200,000 (cost savings) + $520,000 (operations) = $1,720,000
Net Benefit: $1,720,000 - $608,500 = $1,111,500
ROI: ($1,111,500 / $608,500) √ó 100 = 183%
</code></pre></p><p>#### 3-Year ROI
<pre><code>Total Investment: $608,500 + ($196,000 √ó 2) = $1,000,500
Total Benefits: $1,720,000 √ó 3 = $5,160,000
Net Benefit: $5,160,000 - $1,000,500 = $4,159,500
ROI: ($4,159,500 / $1,000,500) √ó 100 = 416%
</code></pre></p><p>#### Payback Period
<pre><code>Monthly Benefits: $1,720,000 / 12 = $143,333
Payback Period: $608,500 / $143,333 = 4.2 months
</code></pre></p><p><h2>Competitive Advantages</h2></p><p><h3>Technical Advantages</h3></p><p>#### Zero Client Changes
<li><strong>Market Differentiation</strong>: No other solution offers zero-impact deployment</li>
<li><strong>Customer Adoption</strong>: Faster customer onboarding and adoption</li>
<li><strong>Risk Reduction</strong>: Eliminates deployment risks and customer concerns</li></p><p>#### Real-time Enforcement
<li><strong>Performance</strong>: Sub-10ms latency impact</li>
<li><strong>Accuracy</strong>: Precise resource measurement and enforcement</li>
<li><strong>Scalability</strong>: Handles 10,000+ requests/second per instance</li></p><p>#### Comprehensive Observability
<li><strong>Visibility</strong>: Real-time monitoring and alerting</li>
<li><strong>Analytics</strong>: Detailed usage analytics and insights</li>
<li><strong>Compliance</strong>: Complete audit trail and reporting</li></p><p><h3>Business Advantages</h3></p><p>#### Revenue Optimization
<li><strong>Usage-Based Billing</strong>: Enables per-tenant resource billing</li>
<li><strong>Overage Management</strong>: Automatic detection and billing of overages</li>
<li><strong>Revenue Recovery</strong>: Recovers lost revenue from resource abuse</li></p><p>#### Customer Experience
<li><strong>Fair Resource Allocation</strong>: Ensures all customers get their fair share</li>
<li><strong>Predictable Performance</strong>: Consistent service quality</li>
<li><strong>Transparent Billing</strong>: Clear resource usage and billing</li></p><p>#### Operational Efficiency
<li><strong>Automation</strong>: Reduces manual operational overhead</li>
<li><strong>Proactive Management</strong>: Early detection and resolution of issues</li>
<li><strong>Scalable Operations</strong>: Supports growth without proportional operational cost increase</li></p><p><h2>Risk Mitigation</h2></p><p><h3>Technical Risks</h3></p><p>#### Service Failure
<li><strong>Risk</strong>: RLS or Envoy service failure</li>
<li><strong>Mitigation</strong>: Configurable failure modes (allow/deny)</li>
<li><strong>Impact</strong>: Minimal service disruption</li>
<li><strong>Cost</strong>: $0 (built-in redundancy)</li></p><p>#### Performance Impact
<li><strong>Risk</strong>: High latency or throughput degradation</li>
<li><strong>Mitigation</strong>: Comprehensive load testing and monitoring</li>
<li><strong>Impact</strong>: <10ms latency impact</li>
<li><strong>Cost</strong>: $50,000 (testing and optimization)</li></p><p>#### Configuration Errors
<li><strong>Risk</strong>: Incorrect tenant limits or enforcement rules</li>
<li><strong>Mitigation</strong>: Configuration validation and testing</li>
<li><strong>Impact</strong>: Minimal with proper testing</li>
<li><strong>Cost</strong>: $25,000 (validation and testing)</li></p><p><h3>Business Risks</h3></p><p>#### Deployment Issues
<li><strong>Risk</strong>: Failed deployment or configuration</li>
<li><strong>Mitigation</strong>: Gradual rollout with rollback capability</li>
<li><strong>Impact</strong>: Zero with proper procedures</li>
<li><strong>Cost</strong>: $0 (built-in rollback)</li></p><p>#### Customer Impact
<li><strong>Risk</strong>: Negative impact on customer experience</li>
<li><strong>Mitigation</strong>: Zero-impact deployment and monitoring</li>
<li><strong>Impact</strong>: Positive (improved service quality)</li>
<li><strong>Cost</strong>: $0 (improved experience)</li></p><p>#### Compliance Issues
<li><strong>Risk</strong>: Regulatory or compliance violations</li>
<li><strong>Mitigation</strong>: Comprehensive audit trail and reporting</li>
<li><strong>Impact</strong>: Improved compliance posture</li>
<li><strong>Cost</strong>: $0 (enhanced compliance)</li></p><p><h2>Success Metrics</h2></p><p><h3>Financial Metrics</h3></p><p>#### Cost Savings
<li><strong>Infrastructure Cost Reduction</strong>: 40-60% reduction in wasted costs</li>
<li><strong>Operational Cost Reduction</strong>: 60-80% reduction in manual overhead</li>
<li><strong>Revenue Recovery</strong>: 15-25% increase in revenue through proper billing</li></p><p>#### ROI Metrics
<li><strong>First Year ROI</strong>: 183%</li>
<li><strong>3-Year ROI</strong>: 416%</li>
<li><strong>Payback Period</strong>: 4.2 months</li></p><p><h3>Operational Metrics</h3></p><p>#### System Performance
<li><strong>Uptime</strong>: 99.95% (improvement from 99.9%)</li>
<li><strong>Latency Impact</strong>: <10ms additional latency</li>
<li><strong>Throughput</strong>: 10,000+ requests/second per instance</li></p><p>#### Customer Experience
<li><strong>Customer Satisfaction</strong>: 95% (improvement from 85%)</li>
<li><strong>Support Tickets</strong>: 30% reduction in resource-related issues</li>
<li><strong>Service Quality</strong>: Consistent performance across all tenants</li></p><p><h3>Business Metrics</h3></p><p>#### Revenue Impact
<li><strong>Resource Billing</strong>: 100% of tenants properly billed</li>
<li><strong>Overage Recovery</strong>: 90% of overages detected and billed</li>
<li><strong>Revenue Growth</strong>: 20% increase in resource-related revenue</li></p><p>#### Operational Efficiency
<li><strong>Team Productivity</strong>: 60-80% reduction in manual monitoring</li>
<li><strong>Response Time</strong>: 50% faster issue detection and resolution</li>
<li><strong>Scalability</strong>: Support 10x growth without proportional operational cost increase</li></p><p><h2>Implementation Timeline</h2></p><p><h3>Phase 1: Development (Months 1-3)</h3>
<li><strong>Deliverables</strong>: Core system development</li>
<li><strong>Investment</strong>: $330,000 - $495,000</li>
<li><strong>Risk</strong>: Low (development phase)</li>
<li><strong>Benefits</strong>: None (development phase)</li></p><p><h3>Phase 2: Testing & Validation (Months 4-5)</h3>
<li><strong>Deliverables</strong>: Testing and refinement</li>
<li><strong>Investment</strong>: $50,000 - $100,000</li>
<li><strong>Risk</strong>: Low (testing phase)</li>
<li><strong>Benefits</strong>: None (testing phase)</li></p><p><h3>Phase 3: Production Deployment (Month 6)</h3>
<li><strong>Deliverables</strong>: Production deployment</li>
<li><strong>Investment</strong>: $50,000</li>
<li><strong>Risk</strong>: Medium (deployment phase)</li>
<li><strong>Benefits</strong>: Immediate cost savings and revenue recovery</li></p><p><h3>Phase 4: Optimization (Months 7-12)</h3>
<li><strong>Deliverables</strong>: Performance optimization and feature enhancement</li>
<li><strong>Investment</strong>: $100,000</li>
<li><strong>Risk</strong>: Low (optimization phase)</li>
<li><strong>Benefits</strong>: Additional cost savings and efficiency improvements</li></p><p><h2>Conclusion</h2></p><p>The Mimir Edge Enforcement system delivers exceptional business value with a compelling ROI of 183% in the first year and 416% over three years. The solution addresses critical business challenges while providing significant competitive advantages.</p><p>Key benefits include:
<li><strong>$1.2M annual cost savings</strong> through resource abuse prevention</li>
<li><strong>$520K annual operational efficiency</strong> improvements</li>
<li><strong>4.2-month payback period</strong> with immediate benefits</li>
<li><strong>Zero deployment risk</strong> with comprehensive rollback capabilities</li>
<li><strong>Competitive differentiation</strong> through unique technical capabilities</li></p><p>The investment is justified by the immediate and long-term benefits, with minimal risk due to the zero-impact deployment strategy and comprehensive monitoring capabilities.</p><p>---</p><p><strong>Recommendation</strong>: Proceed with implementation based on the compelling business case and low-risk deployment strategy.</p><p><strong>Next Steps</strong>: 
<li>Secure executive approval for the $608K initial investment</li>
<li>Begin Phase 1 development with 3 engineers</li>
<li>Establish success metrics and monitoring framework</li>
<li>Plan Phase 2 testing and validation approach</li></p><p>---</p><p>
<h2>Problem Statement</h2></p><p>
<h2>Overview</h2></p><p>This document outlines the critical challenges and pain points that the Mimir Edge Enforcement system addresses in modern observability and monitoring environments.</p><p><h2>Business Challenges</h2></p><p><h3>1. Uncontrolled Infrastructure Costs</h3></p><p>#### Problem
<li><strong>Exponential Cost Growth</strong>: Monitoring infrastructure costs growing 300-500% year-over-year</li>
<li><strong>No Visibility</strong>: Lack of real-time visibility into cost drivers and usage patterns</li>
<li><strong>Budget Overruns</strong>: Monthly infrastructure bills exceeding allocated budgets by 200-400%</li>
<li><strong>Resource Waste</strong>: 40-60% of monitoring resources consumed by non-critical or duplicate data</li></p><p>#### Impact
<li><strong>Financial</strong>: $500K - $2M annual overspend on monitoring infrastructure</li>
<li><strong>Operational</strong>: Delayed feature development due to cost constraints</li>
<li><strong>Strategic</strong>: Reduced investment in core business initiatives</li></p><p>#### Root Causes
<li>No centralized rate limiting or quota enforcement</li>
<li>Inability to differentiate between critical and non-critical metrics</li>
<li>Lack of tenant-aware resource allocation</li>
<li>Missing cost attribution and chargeback mechanisms</li></p><p><h3>2. Service Reliability Degradation</h3></p><p>#### Problem
<li><strong>Performance Degradation</strong>: 30-50% increase in query response times during peak loads</li>
<li><strong>Service Outages</strong>: 2-3 major outages per quarter due to resource exhaustion</li>
<li><strong>Cascading Failures</strong>: Single tenant's excessive usage affecting all users</li>
<li><strong>Resource Contention</strong>: CPU and memory contention leading to service degradation</li></p><p>#### Impact
<li><strong>User Experience</strong>: 40-60% increase in support tickets during peak periods</li>
<li><strong>Business Continuity</strong>: Critical business operations disrupted during outages</li>
<li><strong>Reputation</strong>: Customer trust and satisfaction impacted by service instability</li></p><p>#### Root Causes
<li>No protection against resource abuse</li>
<li>Missing circuit breakers and throttling mechanisms</li>
<li>Inadequate resource isolation between tenants</li>
<li>Lack of proactive monitoring and alerting</li></p><p><h3>3. Operational Complexity</h3></p><p>#### Problem
<li><strong>Manual Interventions</strong>: 15-20 hours per week spent on manual resource management</li>
<li><strong>Reactive Operations</strong>: 80% of operational work is reactive rather than proactive</li>
<li><strong>Knowledge Silos</strong>: Critical operational knowledge concentrated in few team members</li>
<li><strong>Inconsistent Policies</strong>: Different rate limiting policies across environments</li></p><p>#### Impact
<li><strong>Productivity</strong>: 25-30% of engineering time spent on operational tasks</li>
<li><strong>Scalability</strong>: Operations team unable to scale with business growth</li>
<li><strong>Risk</strong>: High dependency on individual team members</li></p><p>#### Root Causes
<li>No automated enforcement mechanisms</li>
<li>Missing centralized policy management</li>
<li>Lack of standardized operational procedures</li>
<li>Insufficient tooling for proactive management</li></p><p><h2>Technical Challenges</h2></p><p><h3>1. Distributed Rate Limiting</h3></p><p>#### Problem
<li><strong>Inconsistent Enforcement</strong>: Rate limits applied differently across services</li>
<li><strong>State Management</strong>: Complex distributed state management for rate limiting</li>
<li><strong>Latency Impact</strong>: Rate limiting decisions adding 50-100ms to request latency</li>
<li><strong>Scalability Issues</strong>: Rate limiting not scaling with traffic growth</li></p><p>#### Technical Details
<pre><code><h1>Current State - Inconsistent Rate Limiting</h1>
services:
  - name: service-a
    rate_limit: 1000 req/sec
    window: 1 minute
  - name: service-b
    rate_limit: 500 req/sec
    window: 5 minutes
  - name: service-c
    rate_limit: none  # No rate limiting
</code></pre></p><p>#### Impact
<li><strong>Reliability</strong>: Inconsistent service behavior</li>
<li><strong>Performance</strong>: Unpredictable latency patterns</li>
<li><strong>Maintenance</strong>: Complex configuration management</li></p><p><h3>2. Multi-Tenant Resource Management</h3></p><p>#### Problem
<li><strong>Resource Isolation</strong>: Poor isolation between tenant workloads</li>
<li><strong>Fair Sharing</strong>: No fair resource allocation mechanisms</li>
<li><strong>Quota Enforcement</strong>: Inability to enforce tenant-specific quotas</li>
<li><strong>Usage Tracking</strong>: Limited visibility into per-tenant resource consumption</li></p><p>#### Technical Details
<pre><code><h1>Current State - No Tenant Isolation</h1>
resources:
  cpu: shared_pool
  memory: shared_pool
  storage: shared_pool
  network: shared_pool</p><p><h1>Desired State - Tenant-Aware Allocation</h1>
resources:
  tenant_a:
    cpu: 20%
    memory: 2GB
    storage: 100GB
  tenant_b:
    cpu: 30%
    memory: 4GB
    storage: 200GB
</code></pre></p><p>#### Impact
<li><strong>Fairness</strong>: Some tenants consuming disproportionate resources</li>
<li><strong>Predictability</strong>: Unpredictable performance for all tenants</li>
<li><strong>Compliance</strong>: Difficulty meeting SLA commitments</li></p><p><h3>3. Real-Time Decision Making</h3></p><p>#### Problem
<li><strong>Latency Requirements</strong>: Need sub-10ms decision latency for rate limiting</li>
<li><strong>Accuracy</strong>: High accuracy requirements for enforcement decisions</li>
<li><strong>Consistency</strong>: Need consistent decisions across distributed components</li>
<li><strong>Scalability</strong>: Must handle 10K+ requests per second</li></p><p>#### Technical Details
<pre><code><h1>Current State - High Latency Decisions</h1>
decision_flow:
  request_received: 0ms
  policy_lookup: 50ms
  rate_limit_check: 100ms
  decision_made: 150ms
  response_sent: 200ms</p><p><h1>Desired State - Low Latency Decisions</h1>
decision_flow:
  request_received: 0ms
  policy_lookup: 2ms
  rate_limit_check: 5ms
  decision_made: 8ms
  response_sent: 10ms
</code></pre></p><p>#### Impact
<li><strong>User Experience</strong>: Poor response times</li>
<li><strong>Throughput</strong>: Limited system capacity</li>
<li><strong>Cost</strong>: Higher infrastructure costs due to inefficiency</li></p><p><h2>Security Challenges</h2></p><p><h3>1. Resource Abuse Prevention</h3></p><p>#### Problem
<li><strong>DDoS Protection</strong>: No protection against distributed denial of service attacks</li>
<li><strong>Resource Exhaustion</strong>: Malicious actors can exhaust system resources</li>
<li><strong>Quota Bypass</strong>: Users can bypass rate limiting through various techniques</li>
<li><strong>Authentication Bypass</strong>: Insufficient authentication and authorization</li></p><p>#### Security Implications
<li><strong>Service Availability</strong>: Risk of complete service outage</li>
<li><strong>Data Integrity</strong>: Potential data corruption or loss</li>
<li><strong>Compliance</strong>: Failure to meet security compliance requirements</li></p><p><h3>2. Audit and Compliance</h3></p><p>#### Problem
<li><strong>Audit Trail</strong>: Insufficient logging of rate limiting decisions</li>
<li><strong>Compliance Reporting</strong>: Difficulty generating compliance reports</li>
<li><strong>Forensic Analysis</strong>: Limited ability to investigate security incidents</li>
<li><strong>Policy Enforcement</strong>: No verification of policy compliance</li></p><p>#### Compliance Requirements
<li><strong>SOC 2</strong>: Security controls and monitoring</li>
<li><strong>GDPR</strong>: Data protection and privacy</li>
<li><strong>ISO 27001</strong>: Information security management</li>
<li><strong>PCI DSS</strong>: Payment card industry compliance</li></p><p><h2>Scalability Challenges</h2></p><p><h3>1. Horizontal Scaling</h3></p><p>#### Problem
<li><strong>State Synchronization</strong>: Complex state synchronization across instances</li>
<li><strong>Load Distribution</strong>: Uneven load distribution across components</li>
<li><strong>Resource Utilization</strong>: Poor resource utilization patterns</li>
<li><strong>Failure Recovery</strong>: Slow recovery from component failures</li></p><p>#### Scaling Requirements
<pre><code><h1>Current Capacity</h1>
requests_per_second: 1,000
concurrent_tenants: 100
data_points_per_second: 10,000</p><p><h1>Target Capacity</h1>
requests_per_second: 100,000
concurrent_tenants: 10,000
data_points_per_second: 1,000,000
</code></pre></p><p><h3>2. Data Management</h3></p><p>#### Problem
<li><strong>Storage Growth</strong>: Exponential storage growth (100% year-over-year)</li>
<li><strong>Query Performance</strong>: Degrading query performance with data growth</li>
<li><strong>Retention Management</strong>: Complex data retention and archival policies</li>
<li><strong>Data Quality</strong>: Inconsistent data quality and completeness</li></p><p>#### Data Challenges
<li><strong>Volume</strong>: Petabytes of time-series data</li>
<li><strong>Velocity</strong>: Millions of data points per second</li>
<li><strong>Variety</strong>: Multiple data formats and sources</li>
<li><strong>Veracity</strong>: Data quality and accuracy concerns</li></p><p><h2>Monitoring and Observability Challenges</h2></p><p><h3>1. Visibility Gaps</h3></p><p>#### Problem
<li><strong>Limited Metrics</strong>: Insufficient metrics for rate limiting decisions</li>
<li><strong>No Correlation</strong>: Unable to correlate rate limiting with business metrics</li>
<li><strong>Alert Fatigue</strong>: Too many alerts with low signal-to-noise ratio</li>
<li><strong>Root Cause Analysis</strong>: Difficulty identifying root causes of issues</li></p><p>#### Observability Requirements
<pre><code><h1>Required Metrics</h1>
rate_limiting:
  - requests_per_second
  - denied_requests
  - allowed_requests
  - latency_percentiles
  - error_rates</p><p>business:
  - cost_per_tenant
  - resource_utilization
  - sla_compliance
  - user_satisfaction
</code></pre></p><p><h3>2. Performance Monitoring</h3></p><p>#### Problem
<li><strong>Latency Spikes</strong>: Unpredictable latency spikes during peak loads</li>
<li><strong>Resource Bottlenecks</strong>: Difficulty identifying resource bottlenecks</li>
<li><strong>Capacity Planning</strong>: Insufficient data for capacity planning</li>
<li><strong>Performance Regression</strong>: Hard to detect performance regressions</li></p><p><h2>Compliance and Governance Challenges</h2></p><p><h3>1. Policy Management</h3></p><p>#### Problem
<li><strong>Policy Complexity</strong>: Complex and conflicting rate limiting policies</li>
<li><strong>Policy Enforcement</strong>: Inconsistent policy enforcement across environments</li>
<li><strong>Policy Updates</strong>: Slow and error-prone policy updates</li>
<li><strong>Policy Auditing</strong>: Difficulty auditing policy compliance</li></p><p>#### Policy Requirements
<pre><code><h1>Policy Types</h1>
policies:
  - tenant_quotas
  - rate_limits
  - resource_limits
  - security_policies
  - compliance_policies</p><p><h1>Enforcement Levels</h1>
enforcement:
  - soft_limits
  - hard_limits
  - graduated_response
  - emergency_shutdown
</code></pre></p><p><h3>2. Regulatory Compliance</h3></p><p>#### Problem
<li><strong>Multiple Regulations</strong>: Need to comply with multiple regulations</li>
<li><strong>Audit Requirements</strong>: Complex audit and reporting requirements</li>
<li><strong>Data Privacy</strong>: Data privacy and protection requirements</li>
<li><strong>Change Management</strong>: Strict change management and approval processes</li></p><p><h2>Solution Requirements</h2></p><p><h3>1. Functional Requirements</h3></p><p>#### Core Functionality
<li><strong>Real-time Rate Limiting</strong>: Sub-10ms rate limiting decisions</li>
<li><strong>Multi-tenant Support</strong>: Support for 10,000+ concurrent tenants</li>
<li><strong>Policy Management</strong>: Centralized policy management and enforcement</li>
<li><strong>Monitoring</strong>: Comprehensive monitoring and alerting</li>
<li><strong>Audit Trail</strong>: Complete audit trail for all decisions</li></p><p>#### Advanced Features
<li><strong>Selective Enforcement</strong>: Ability to selectively apply enforcement</li>
<li><strong>Time-based Aggregation</strong>: Intelligent time-based metric aggregation</li>
<li><strong>Dynamic Scaling</strong>: Automatic scaling based on load</li>
<li><strong>Fail-safe Operation</strong>: Graceful degradation during failures</li></p><p><h3>2. Non-Functional Requirements</h3></p><p>#### Performance
<li><strong>Latency</strong>: <10ms for rate limiting decisions</li>
<li><strong>Throughput</strong>: 100,000 requests per second</li>
<li><strong>Availability</strong>: 99.9% uptime</li>
<li><strong>Scalability</strong>: Linear scaling with load</li></p><p>#### Reliability
<li><strong>Fault Tolerance</strong>: Continue operation during component failures</li>
<li><strong>Data Consistency</strong>: Consistent data across distributed components</li>
<li><strong>Recovery Time</strong>: <5 minutes recovery from failures</li>
<li><strong>Backup and Restore</strong>: Automated backup and restore capabilities</li></p><p>#### Security
<li><strong>Authentication</strong>: Strong authentication mechanisms</li>
<li><strong>Authorization</strong>: Role-based access control</li>
<li><strong>Encryption</strong>: Data encryption in transit and at rest</li>
<li><strong>Audit</strong>: Comprehensive audit logging</li></p><p><h3>3. Operational Requirements</h3></p><p>#### Deployment
<li><strong>Zero Downtime</strong>: Zero-downtime deployments</li>
<li><strong>Rollback</strong>: Quick rollback capabilities</li>
<li><strong>Configuration Management</strong>: Centralized configuration management</li>
<li><strong>Environment Consistency</strong>: Consistent behavior across environments</li></p><p>#### Monitoring
<li><strong>Health Checks</strong>: Comprehensive health check mechanisms</li>
<li><strong>Alerting</strong>: Intelligent alerting with low false positives</li>
<li><strong>Dashboards</strong>: Real-time dashboards for operational visibility</li>
<li><strong>Logging</strong>: Structured logging for operational analysis</li></p><p><h2>Success Criteria</h2></p><p><h3>1. Business Metrics</h3></p><p>#### Cost Reduction
<li><strong>Infrastructure Costs</strong>: 50-70% reduction in monitoring infrastructure costs</li>
<li><strong>Operational Costs</strong>: 40-60% reduction in operational overhead</li>
<li><strong>Time to Resolution</strong>: 80% reduction in time to resolve issues</li>
<li><strong>Resource Utilization</strong>: 30-50% improvement in resource utilization</li></p><p>#### Service Quality
<li><strong>Availability</strong>: 99.9% service availability</li>
<li><strong>Performance</strong>: <10ms average response time</li>
<li><strong>Reliability</strong>: <1% error rate</li>
<li><strong>User Satisfaction</strong>: >95% user satisfaction score</li></p><p><h3>2. Technical Metrics</h3></p><p>#### Performance
<li><strong>Throughput</strong>: 100,000 requests per second</li>
<li><strong>Latency</strong>: <10ms p95 latency</li>
<li><strong>Scalability</strong>: Linear scaling with load</li>
<li><strong>Efficiency</strong>: 90%+ resource utilization</li></p><p>#### Reliability
<li><strong>Uptime</strong>: 99.9% uptime</li>
<li><strong>Recovery</strong>: <5 minutes recovery time</li>
<li><strong>Consistency</strong>: 99.99% data consistency</li>
<li><strong>Durability</strong>: 99.999% data durability</li></p><p><h3>3. Operational Metrics</h3></p><p>#### Efficiency
<li><strong>Automation</strong>: 90%+ operational tasks automated</li>
<li><strong>Response Time</strong>: <15 minutes response to incidents</li>
<li><strong>Resolution Time</strong>: <2 hours resolution time</li>
<li><strong>Change Velocity</strong>: 10x increase in deployment frequency</li></p><p>#### Quality
<li><strong>Defect Rate</strong>: <1% defect rate in production</li>
<li><strong>Rollback Rate</strong>: <5% rollback rate</li>
<li><strong>Compliance</strong>: 100% compliance with policies</li>
<li><strong>Documentation</strong>: 100% documentation coverage</li></p><p><h2>Conclusion</h2></p><p>The Mimir Edge Enforcement system addresses critical challenges in modern observability environments by providing:</p><p><li><strong>Cost Control</strong>: Automated cost management and resource optimization</li>
<li><strong>Service Protection</strong>: Proactive protection against resource abuse and service degradation</li>
<li><strong>Operational Excellence</strong>: Automated operations with comprehensive monitoring</li>
<li><strong>Compliance</strong>: Built-in compliance and governance capabilities</li>
<li><strong>Scalability</strong>: Linear scaling with business growth</li></p><p>By solving these challenges, the system enables organizations to:
<li>Reduce infrastructure costs by 50-70%</li>
<li>Improve service reliability and performance</li>
<li>Scale operations efficiently</li>
<li>Meet compliance requirements</li>
<li>Focus on core business objectives</li></p><p>---</p><p><strong>Next Steps</strong>: 
<li>Review the solution architecture in <code>architecture/system-architecture.md</code></li>
<li>Understand the business value in <code>business-value.md</code></li>
<li>Explore implementation details in <code>components/rate-limit-service.md</code></li>
<li>Review deployment strategy in <code>deployment/deployment-strategy.md</code></li></p><p><strong>Related Documents</strong>:
<li>[Executive Summary](executive-summary.md)</li>
<li>[Business Value](business-value.md)</li>
<li>[System Architecture](architecture/system-architecture.md)</li>
<li>[Deployment Strategy](deployment/deployment-strategy.md)</li></p><p>---</p><p>
<h2>System Architecture</h2></p><p>
<h2>Overview</h2></p><p>The Mimir Edge Enforcement system is designed as a modular, cloud-agnostic Kubernetes solution that enforces tenant ingestion limits at the edge with zero client changes and comprehensive observability.</p><p><h2>High-Level System Architecture</h2></p><p><h3>System Components Diagram</h3></p><p><pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                              Mimir Edge Enforcement                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ   Alloy     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   NGINX     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Envoy     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Mimir     ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  (Client)   ‚îÇ    ‚îÇ  (Proxy)    ‚îÇ    ‚îÇ (Edge)      ‚îÇ    ‚îÇDistributor  ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                           ‚îÇ                   ‚îÇ                                ‚îÇ
‚îÇ                           ‚ñº                   ‚ñº                                ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ                    ‚îÇ   RLS       ‚îÇ    ‚îÇOverrides-   ‚îÇ                         ‚îÇ
‚îÇ                    ‚îÇ(Auth/Rate)  ‚îÇ    ‚îÇSync         ‚îÇ                         ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îÇ
‚îÇ                           ‚îÇ                   ‚îÇ                                ‚îÇ
‚îÇ                           ‚ñº                   ‚ñº                                ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ                    ‚îÇ  Admin UI   ‚îÇ    ‚îÇ   Mimir     ‚îÇ                         ‚îÇ
‚îÇ                    ‚îÇ  (React)    ‚îÇ    ‚îÇ Overrides   ‚îÇ                         ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ ConfigMap   ‚îÇ                         ‚îÇ
‚îÇ                                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îÇ
‚îÇ                                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></p><p><h3>Component Interaction Flow</h3></p><p><pre><code>graph TB
    A[Alloy Client] --> B[NGINX Proxy]
    B --> C[Envoy Proxy]
    C --> D[RLS Service]
    D --> E[Token Buckets]
    D --> F[Tenant Limits]
    C --> G[Mimir Distributor]
    H[Overrides-Sync] --> I[Mimir ConfigMap]
    H --> D
    J[Admin UI] --> D
    K[Prometheus] --> D
    K --> C
    K --> H
    L[Grafana] --> K
</code></pre></p><p><h2>Detailed Component Architecture</h2></p><p><h3>1. Client Layer</h3></p><p>#### Alloy Client
<li><strong>Purpose</strong>: Prometheus remote write client</li>
<li><strong>Protocol</strong>: HTTP/HTTPS</li>
<li><strong>Authentication</strong>: Bearer token or API key</li>
<li><strong>Compression</strong>: gzip, snappy, or uncompressed</li>
<li><strong>Batch Size</strong>: Configurable (default: 1MB)</li></p><p>#### NGINX Proxy
<li><strong>Purpose</strong>: Load balancer and traffic router</li>
<li><strong>Features</strong>:</li>
  - SSL termination
  - Request routing
  - Traffic splitting (mirror/canary)
  - Health checks
  - Rate limiting (coarse)
<li><strong>Configuration</strong>: Dynamic reload capability</li></p><p><h3>2. Edge Layer</h3></p><p>#### Envoy Proxy
<li><strong>Purpose</strong>: HTTP proxy with external authorization</li>
<li><strong>Filters</strong>:</li>
  - <code>ext_authz</code>: External authorization filter
  - <code>rate_limit</code>: Rate limiting filter
  - <code>cors</code>: Cross-origin resource sharing
  - <code>compressor</code>: Response compression
<li><strong>Protocols</strong>: HTTP/1.1, HTTP/2, gRPC</li>
<li><strong>Clusters</strong>: RLS service clusters</li></p><p><h3>3. Enforcement Layer</h3></p><p>#### Rate Limit Service (RLS)
<li><strong>Purpose</strong>: Core enforcement engine</li>
<li><strong>Services</strong>:</li>
  - gRPC ext_authz server
  - gRPC ratelimit server
  - HTTP admin API
<li><strong>Features</strong>:</li>
  - Protobuf parsing
  - Token bucket algorithm
  - Time-based aggregation
  - Intelligent caching</p><p><h3>4. Management Layer</h3></p><p>#### Overrides-Sync Controller
<li><strong>Purpose</strong>: Kubernetes controller for limit management</li>
<li><strong>Features</strong>:</li>
  - ConfigMap watcher
  - Limit parsing
  - RLS synchronization
  - Fallback polling
<li><strong>Reconciliation</strong>: Event-driven with polling fallback</li></p><p>#### Admin UI
<li><strong>Purpose</strong>: Web-based management interface</li>
<li><strong>Technology</strong>: React 18 + TypeScript</li>
<li><strong>Features</strong>:</li>
  - Real-time monitoring
  - Tenant management
  - Configuration interface
  - Export capabilities</p><p><h3>5. Storage Layer</h3></p><p>#### In-Memory Storage
<li><strong>Purpose</strong>: Primary state storage</li>
<li><strong>Data</strong>: Tenant limits, token buckets, metrics</li>
<li><strong>Persistence</strong>: Optional Redis backend</li>
<li><strong>Scaling</strong>: Horizontal scaling with state sharing</li></p><p>#### Kubernetes Resources
<li><strong>ConfigMaps</strong>: Mimir overrides configuration</li>
<li><strong>Secrets</strong>: TLS certificates, API keys</li>
<li><strong>PersistentVolumes</strong>: Optional Redis storage</li></p><p><h2>Data Flow Architecture</h2></p><p><h3>1. Normal Request Flow</h3></p><p><pre><code>sequenceDiagram
    participant A as Alloy Client
    participant N as NGINX
    participant E as Envoy
    participant R as RLS
    participant M as Mimir Distributor</p><p>    A->>N: POST /api/v1/push
    N->>E: Forward request
    E->>R: ext_authz.Check()
    R->>R: Parse protobuf body
    R->>R: Check tenant limits
    R->>R: Update token buckets
    R-->>E: ALLOW/DENY response
    alt ALLOW
        E->>M: Forward to distributor
        M-->>E: Response
        E-->>N: Response
        N-->>A: Response
    else DENY
        E-->>N: 429 Too Many Requests
        N-->>A: 429 Too Many Requests
    end
</code></pre></p><p><h3>2. Rate Limiting Flow</h3></p><p><pre><code>sequenceDiagram
    participant E as Envoy
    participant R as RLS
    participant T as Token Bucket</p><p>    E->>R: ratelimit.ShouldRateLimit()
    R->>T: Check bucket capacity
    alt Sufficient tokens
        T-->>R: OK
        R-->>E: OK
    else Insufficient tokens
        T-->>R: OVER_LIMIT
        R-->>E: OVER_LIMIT
    end
</code></pre></p><p><h3>3. Configuration Sync Flow</h3></p><p><pre><code>sequenceDiagram
    participant K as Kubernetes
    participant O as Overrides-Sync
    participant R as RLS</p><p>    K->>O: ConfigMap updated
    O->>O: Parse overrides
    O->>R: SetTenantLimits()
    R->>R: Update token buckets
    R-->>O: Success
</code></pre></p><p><h2>Network Architecture</h2></p><p><h3>Network Topology</h3></p><p><pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                              Kubernetes Cluster                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                              Ingress Layer                                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   NGINX     ‚îÇ  ‚îÇ   NGINX     ‚îÇ  ‚îÇ   NGINX     ‚îÇ  ‚îÇ   NGINX     ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  Ingress    ‚îÇ  ‚îÇ  Ingress    ‚îÇ  ‚îÇ  Ingress    ‚îÇ  ‚îÇ  Ingress    ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Controller  ‚îÇ  ‚îÇ Controller  ‚îÇ  ‚îÇ Controller  ‚îÇ  ‚îÇ Controller  ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                    ‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                              Service Layer                                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Envoy     ‚îÇ  ‚îÇ   Envoy     ‚îÇ  ‚îÇ   Envoy     ‚îÇ  ‚îÇ   Envoy     ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Proxy     ‚îÇ  ‚îÇ   Proxy     ‚îÇ  ‚îÇ   Proxy     ‚îÇ  ‚îÇ   Proxy     ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                    ‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                            Enforcement Layer                                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ     RLS     ‚îÇ  ‚îÇ     RLS     ‚îÇ  ‚îÇ     RLS     ‚îÇ  ‚îÇ     RLS     ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Service   ‚îÇ  ‚îÇ   Service   ‚îÇ  ‚îÇ   Service   ‚îÇ  ‚îÇ   Service   ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                    ‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                             Management Layer                                 ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Overrides-  ‚îÇ  ‚îÇ   Admin     ‚îÇ  ‚îÇ Prometheus  ‚îÇ  ‚îÇ   Grafana   ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Sync      ‚îÇ  ‚îÇ     UI      ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Controller  ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></p><p><h3>Network Policies</h3></p><p>#### Pod-to-Pod Communication
<pre><code>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: mimir-edge-enforcement-network-policy
spec:
  podSelector:
    matchLabels:
      app: mimir-edge-enforcement
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: nginx-ingress
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: mimir-distributor
    ports:
    - protocol: TCP
      port: 8080
</code></pre></p><p><h2>Security Architecture</h2></p><p><h3>Authentication & Authorization</h3></p><p>#### Tenant Identification
<li><strong>Method</strong>: HTTP header extraction</li>
<li><strong>Default Header</strong>: <code>X-Scope-OrgID</code></li>
<li><strong>Configurable</strong>: Custom header support</li>
<li><strong>Validation</strong>: Header presence and format</li></p><p>#### Service Authentication
<li><strong>gRPC</strong>: mTLS for inter-service communication</li>
<li><strong>HTTP</strong>: Bearer tokens for admin API</li>
<li><strong>Kubernetes</strong>: Service accounts and RBAC</li></p><p><h3>Data Protection</h3></p><p>#### Request Body Handling
<li><strong>Size Limits</strong>: Configurable (default: 50MB)</li>
<li><strong>Parsing</strong>: Protobuf parsing with validation</li>
<li><strong>Logging</strong>: No sensitive data in logs</li>
<li><strong>Storage</strong>: In-memory only, no persistence</li></p><p>#### Metrics & Logging
<li><strong>Tenant Context</strong>: Tenant ID in all metrics</li>
<li><strong>Privacy</strong>: No sensitive data exposure</li>
<li><strong>Retention</strong>: Configurable retention policies</li>
<li><strong>Audit</strong>: Complete request audit trail</li></p><p><h2>Scalability Architecture</h2></p><p><h3>Horizontal Scaling</h3></p><p>#### Auto-Scaling Configuration
<pre><code>apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: mimir-rls-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: mimir-rls
  minReplicas: 10
  maxReplicas: 40
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 60
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 60
</code></pre></p><p>#### Load Distribution
<li><strong>Algorithm</strong>: Round-robin with health checks</li>
<li><strong>Session Affinity</strong>: Optional for stateful operations</li>
<li><strong>Health Checks</strong>: Liveness and readiness probes</li>
<li><strong>Circuit Breaker</strong>: Automatic failure detection</li></p><p><h3>State Management</h3></p><p>#### In-Memory State
<li><strong>Primary</strong>: In-memory storage for performance</li>
<li><strong>Scaling</strong>: State sharing across replicas</li>
<li><strong>Consistency</strong>: Eventual consistency model</li>
<li><strong>Recovery</strong>: Automatic state reconstruction</li></p><p>#### Optional Redis Backend
<li><strong>Purpose</strong>: Shared state across replicas</li>
<li><strong>Configuration</strong>: Optional for high-scale deployments</li>
<li><strong>Fallback</strong>: In-memory if Redis unavailable</li>
<li><strong>Performance</strong>: Minimal latency impact</li></p><p><h2>High Availability</h2></p><p><h3>Multi-Zone Deployment</h3></p><p>#### Pod Anti-Affinity
<pre><code>spec:
  template:
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - mimir-rls
              topologyKey: kubernetes.io/hostname
</code></pre></p><p>#### Pod Disruption Budget
<pre><code>apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: mimir-rls-pdb
spec:
  minAvailable: 5
  selector:
    matchLabels:
      app: mimir-rls
</code></pre></p><p><h3>Failure Recovery</h3></p><p>#### Service Failure Modes
<li><strong>ext_authz</strong>: Configurable (allow/deny on failure)</li>
<li><strong>ratelimit</strong>: Configurable (allow/deny on failure)</li>
<li><strong>RLS Service</strong>: Automatic restart via Kubernetes</li>
<li><strong>Envoy Proxy</strong>: Health check failover</li></p><p>#### Data Recovery
<li><strong>State Loss</strong>: Automatic reconstruction from ConfigMap</li>
<li><strong>Metrics Loss</strong>: Prometheus handles gaps</li>
<li><strong>Configuration Loss</strong>: ConfigMap sync restores limits</li></p><p><h2>Monitoring Architecture</h2></p><p><h3>Metrics Collection</h3></p><p>#### Prometheus Integration
<li><strong>Scraping</strong>: ServiceMonitor for automatic discovery</li>
<li><strong>Metrics</strong>: Custom metrics for all components</li>
<li><strong>Labels</strong>: Tenant-aware metric labeling</li>
<li><strong>Retention</strong>: Configurable retention policies</li></p><p>#### Custom Metrics
<li><strong>RLS Metrics</strong>: Decisions, latency, errors</li>
<li><strong>Envoy Metrics</strong>: HTTP stats, filter stats</li>
<li><strong>Business Metrics</strong>: Tenant utilization, denials</li>
<li><strong>System Metrics</strong>: Resource usage, health status</li></p><p><h3>Logging Strategy</h3></p><p>#### Structured Logging
<li><strong>Format</strong>: JSON structured logs</li>
<li><strong>Levels</strong>: DEBUG, INFO, WARN, ERROR</li>
<li><strong>Context</strong>: Tenant ID, request ID, correlation ID</li>
<li><strong>Output</strong>: stdout/stderr for Kubernetes</li></p><p>#### Log Aggregation
<li><strong>Collection</strong>: Kubernetes log aggregation</li>
<li><strong>Processing</strong>: Optional log processing pipeline</li>
<li><strong>Storage</strong>: Centralized log storage</li>
<li><strong>Search</strong>: Full-text search capabilities</li></p><p><h2>Configuration Management</h2></p><p><h3>Dynamic Configuration</h3></p><p>#### ConfigMap Integration
<li><strong>Source</strong>: Mimir overrides ConfigMap</li>
<li><strong>Sync</strong>: Real-time ConfigMap watching</li>
<li><strong>Fallback</strong>: Polling when watch fails</li>
<li><strong>Validation</strong>: Configuration validation</li></p><p>#### Environment Variables
<li><strong>Runtime</strong>: Environment variable configuration</li>
<li><strong>Secrets</strong>: Kubernetes secrets for sensitive data</li>
<li><strong>Validation</strong>: Configuration validation at startup</li>
<li><strong>Documentation</strong>: Comprehensive configuration docs</li></p><p><h3>Configuration Validation</h3></p><p>#### Schema Validation
<li><strong>Format</strong>: JSON schema validation</li>
<li><strong>Types</strong>: Strong typing for all configurations</li>
<li><strong>Defaults</strong>: Sensible defaults for all options</li>
<li><strong>Documentation</strong>: Inline configuration documentation</li></p><p><h2>Integration Points</h2></p><p><h3>External Systems</h3></p><p>#### Mimir Integration
<li><strong>Protocol</strong>: HTTP/HTTPS</li>
<li><strong>Authentication</strong>: Bearer tokens</li>
<li><strong>Configuration</strong>: ConfigMap synchronization</li>
<li><strong>Monitoring</strong>: Mimir metrics integration</li></p><p>#### Kubernetes Integration
<li><strong>Resources</strong>: Native Kubernetes resources</li>
<li><strong>RBAC</strong>: Role-based access control</li>
<li><strong>Networking</strong>: Network policies and services</li>
<li><strong>Storage</strong>: Persistent volumes and secrets</li></p><p>#### Monitoring Integration
<li><strong>Prometheus</strong>: Metrics scraping and alerting</li>
<li><strong>Grafana</strong>: Dashboard and visualization</li>
<li><strong>AlertManager</strong>: Alert routing and notification</li>
<li><strong>Logging</strong>: Centralized log aggregation</li></p><p><h2>Performance Considerations</h2></p><p><h3>Latency Optimization</h3></p><p>#### Request Processing
<li><strong>Parsing</strong>: Optimized protobuf parsing</li>
<li><strong>Validation</strong>: Minimal validation overhead</li>
<li><strong>Caching</strong>: Intelligent caching strategies</li>
<li><strong>Batching</strong>: Request batching where possible</li></p><p>#### Network Optimization
<li><strong>Connection Pooling</strong>: HTTP/2 connection reuse</li>
<li><strong>Compression</strong>: Response compression</li>
<li><strong>Caching</strong>: Response caching strategies</li>
<li><strong>Load Balancing</strong>: Efficient load distribution</li></p><p><h3>Resource Optimization</h3></p><p>#### Memory Management
<li><strong>Allocation</strong>: Efficient memory allocation</li>
<li><strong>Garbage Collection</strong>: Optimized GC settings</li>
<li><strong>Caching</strong>: Memory-efficient caching</li>
<li><strong>Monitoring</strong>: Memory usage monitoring</li></p><p>#### CPU Optimization
<li><strong>Concurrency</strong>: Efficient concurrency patterns</li>
<li><strong>Profiling</strong>: Regular performance profiling</li>
<li><strong>Optimization</strong>: Continuous performance optimization</li>
<li><strong>Monitoring</strong>: CPU usage monitoring</li></p><p><h2>Conclusion</h2></p><p>The Mimir Edge Enforcement system architecture provides a comprehensive, scalable, and maintainable solution for tenant limit enforcement at the edge. The modular design ensures clear separation of concerns, while the comprehensive monitoring and observability capabilities enable effective operation and troubleshooting.</p><p>The architecture supports both current requirements and future growth, with clear upgrade paths and enhancement capabilities. The security-first approach ensures data protection and compliance, while the performance optimizations deliver minimal latency impact.</p><p>---</p><p><strong>Next Steps</strong>: Review component-specific architecture documents for detailed implementation details.</p><p>---</p><p>
<h2>Component Architecture</h2></p><p>
<h2>Overview</h2></p><p>This document provides a detailed architectural overview of each component in the Mimir Edge Enforcement system, including their responsibilities, interactions, and design patterns.</p><p><h2>Architecture Overview</h2></p><p><h3>High-Level Component Diagram</h3></p><p><pre><code>graph TB
    Client[Client Applications] --> NGINX[NGINX Proxy]
    NGINX --> RLS[Rate Limit Service]
    NGINX --> Distributor[Mimir Distributor]
    RLS --> Envoy[Envoy Proxy]
    Envoy --> Distributor
    RLS --> Controller[Overrides-Sync Controller]
    Controller --> K8s[Kubernetes API]
    Admin[Admin UI] --> RLS
    Grafana[Grafana] --> RLS
    Prometheus[Prometheus] --> RLS
    
    subgraph "Edge Layer"
        NGINX
    end
    
    subgraph "Enforcement Layer"
        RLS
        Envoy
    end
    
    subgraph "Management Layer"
        Controller
        Admin
    end
    
    subgraph "Storage Layer"
        K8s
    end
    
    subgraph "Observability Layer"
        Grafana
        Prometheus
    end
</code></pre></p><p><h2>Component Details</h2></p><p><h3>1. NGINX Proxy (Edge Layer)</h3></p><p>#### Purpose
The NGINX proxy serves as the entry point for all incoming traffic and implements selective routing based on user identity.</p><p>#### Responsibilities
<li><strong>Traffic Routing</strong>: Route traffic based on user identity (<code>$remote_user</code>)</li>
<li><strong>Load Balancing</strong>: Distribute traffic across backend services</li>
<li><strong>SSL Termination</strong>: Handle SSL/TLS termination</li>
<li><strong>Request Logging</strong>: Log all requests with routing decisions</li>
<li><strong>Health Checking</strong>: Monitor backend service health</li></p><p>#### Architecture
<pre><code><h1>Core Routing Logic</h1>
map $remote_user $route_decision {
    "boltx"      "edge";
    "cloudwatch" "edge";
    default      "direct";
}</p><p><h1>Selective Proxy Configuration</h1>
location /api/v1/push {
    if ($route_decision = "edge") {
        proxy_pass http://mimir_rls;
        add_header X-Edge-Enforcement "selective";
    }
    if ($route_decision = "direct") {
        proxy_pass http://mimir_direct;
        add_header X-Edge-Enforcement "none";
    }
    add_header X-Route-Decision $route_decision;
}
</code></pre></p><p>#### Key Features
<li><strong>User-based Routing</strong>: Route traffic based on user identity</li>
<li><strong>Selective Enforcement</strong>: Apply rate limiting only to specific users</li>
<li><strong>Transparent Proxy</strong>: Maintain original request headers and metadata</li>
<li><strong>Health Monitoring</strong>: Monitor backend service availability</li></p><p>#### Performance Characteristics
<li><strong>Latency</strong>: <1ms routing overhead</li>
<li><strong>Throughput</strong>: 100,000+ requests per second</li>
<li><strong>Memory</strong>: <100MB per instance</li>
<li><strong>CPU</strong>: <5% CPU utilization under normal load</li></p><p><h3>2. Rate Limit Service (RLS)</h3></p><p>#### Purpose
The Rate Limit Service is the core enforcement engine that implements rate limiting, quota management, and policy enforcement.</p><p>#### Responsibilities
<li><strong>Rate Limiting</strong>: Implement token bucket rate limiting</li>
<li><strong>Quota Management</strong>: Enforce tenant-specific quotas</li>
<li><strong>Policy Enforcement</strong>: Apply rate limiting policies</li>
<li><strong>Metrics Collection</strong>: Collect and aggregate metrics</li>
<li><strong>gRPC Services</strong>: Provide ext_authz and rate limit gRPC APIs</li></p><p>#### Architecture
<pre><code>// Core Service Structure
type RateLimitService struct {
    tenants        map[string]*TenantInfo
    tokenBuckets   map[string]*TokenBucket
    timeAggregator *TimeAggregator
    metrics        *MetricsCollector
    config         *Config
}</p><p>// Request Processing Flow
func (rls *RateLimitService) CheckRemoteWriteLimits(tenantID string, body []byte, encoding string) error {
    // 1. Extract tenant information
    tenant := rls.GetOrCreateTenant(tenantID)
    
    // 2. Parse request body
    metrics, err := rls.parseMetrics(body, encoding)
    
    // 3. Check rate limits
    allowed, err := rls.checkRateLimits(tenant, metrics)
    
    // 4. Update metrics
    rls.updateMetrics(tenant, metrics, allowed)
    
    return err
}
</code></pre></p><p>#### Key Features
<li><strong>Token Bucket Algorithm</strong>: Efficient rate limiting with burst support</li>
<li><strong>Time-based Aggregation</strong>: Intelligent metric aggregation over time</li>
<li><strong>Multi-tenant Support</strong>: Isolated rate limiting per tenant</li>
<li><strong>Dynamic Configuration</strong>: Runtime configuration updates</li>
<li><strong>Comprehensive Metrics</strong>: Detailed metrics for monitoring and alerting</li></p><p>#### Performance Characteristics
<li><strong>Latency</strong>: <5ms for rate limiting decisions</li>
<li><strong>Throughput</strong>: 50,000+ requests per second</li>
<li><strong>Memory</strong>: <2GB per instance</li>
<li><strong>CPU</strong>: <20% CPU utilization under normal load</li></p><p>#### API Endpoints
<pre><code><h1>gRPC Services</h1>
grpc_services:
  - name: ext_authz
    port: 8080
    protocol: grpc
    purpose: External authorization decisions
    
  - name: rate_limit
    port: 8081
    protocol: grpc
    purpose: Rate limiting decisions</p><p><h1>HTTP Admin API</h1>
http_endpoints:
  - path: /api/tenants
    method: GET
    purpose: List tenants with metrics
    
  - path: /api/overview
    method: GET
    purpose: System overview metrics
    
  - path: /api/health
    method: GET
    purpose: Health check
</code></pre></p><p><h3>3. Envoy Proxy</h3></p><p>#### Purpose
Envoy Proxy serves as the internal proxy that handles communication between the RLS and Mimir Distributor, implementing additional rate limiting and load balancing.</p><p>#### Responsibilities
<li><strong>Internal Routing</strong>: Route requests between RLS and Distributor</li>
<li><strong>Rate Limiting</strong>: Apply additional rate limiting filters</li>
<li><strong>Load Balancing</strong>: Distribute load across Distributor instances</li>
<li><strong>Circuit Breaking</strong>: Implement circuit breakers for fault tolerance</li>
<li><strong>Metrics Collection</strong>: Collect proxy-level metrics</li></p><p>#### Architecture
<pre><code><h1>Envoy Configuration</h1>
static_resources:
  listeners:
    - name: mimir_listener
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8080
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: mimir
                route_config:
                  name: mimir_route
                  virtual_hosts:
                    - name: mimir
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: mimir_distributor
                http_filters:
                  - name: envoy.filters.http.ext_authz
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
                      grpc_service:
                        envoy_grpc:
                          cluster_name: rls_service
                  - name: envoy.filters.http.rate_limit
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.rate_limit.v3.RateLimit
                      domain: mimir
                      rate_limit_service:
                        grpc_service:
                          envoy_grpc:
                            cluster_name: rls_service
</code></pre></p><p>#### Key Features
<li><strong>Ext Authz Integration</strong>: External authorization with RLS</li>
<li><strong>Rate Limiting</strong>: Additional rate limiting layer</li>
<li><strong>Load Balancing</strong>: Round-robin load balancing</li>
<li><strong>Health Checking</strong>: Active health checking</li>
<li><strong>Circuit Breaking</strong>: Fault tolerance mechanisms</li></p><p>#### Performance Characteristics
<li><strong>Latency</strong>: <2ms proxy overhead</li>
<li><strong>Throughput</strong>: 100,000+ requests per second</li>
<li><strong>Memory</strong>: <500MB per instance</li>
<li><strong>CPU</strong>: <10% CPU utilization under normal load</li></p><p><h3>4. Overrides-Sync Controller</h3></p><p>#### Purpose
The Overrides-Sync Controller manages the synchronization of rate limiting configurations between Kubernetes ConfigMaps and the RLS service.</p><p>#### Responsibilities
<li><strong>Config Synchronization</strong>: Sync ConfigMap changes to RLS</li>
<li><strong>Dynamic Updates</strong>: Update rate limiting policies without restarts</li>
<li><strong>Validation</strong>: Validate configuration changes</li>
<li><strong>Rollback</strong>: Support configuration rollbacks</li>
<li><strong>Audit Trail</strong>: Maintain configuration change history</li></p><p>#### Architecture
<pre><code>// Controller Structure
type OverridesSyncController struct {
    k8sClient    kubernetes.Interface
    rlsClient    *RLSClient
    configMapWatcher *ConfigMapWatcher
    eventRecorder record.EventRecorder
}</p><p>// Configuration Sync Flow
func (c *OverridesSyncController) syncConfigMap(namespace, name string) error {
    // 1. Get ConfigMap from Kubernetes
    configMap, err := c.k8sClient.CoreV1().ConfigMaps(namespace).Get(name, metav1.GetOptions{})
    
    // 2. Parse configuration
    config, err := c.parseConfig(configMap.Data)
    
    // 3. Validate configuration
    if err := c.validateConfig(config); err != nil {
        return err
    }
    
    // 4. Sync to RLS
    return c.rlsClient.UpdateConfig(config)
}
</code></pre></p><p>#### Key Features
<li><strong>Real-time Sync</strong>: Immediate configuration updates</li>
<li><strong>Validation</strong>: Comprehensive configuration validation</li>
<li><strong>Rollback Support</strong>: Quick rollback to previous configurations</li>
<li><strong>Audit Logging</strong>: Complete audit trail of changes</li>
<li><strong>Error Handling</strong>: Graceful error handling and recovery</li></p><p>#### Performance Characteristics
<li><strong>Sync Latency</strong>: <1 second for configuration updates</li>
<li><strong>Memory</strong>: <100MB per instance</li>
<li><strong>CPU</strong>: <5% CPU utilization</li>
<li><strong>Reliability</strong>: 99.9% configuration sync success rate</li></p><p><h3>5. Admin UI</h3></p><p>#### Purpose
The Admin UI provides a web-based interface for monitoring, managing, and configuring the Mimir Edge Enforcement system.</p><p>#### Responsibilities
<li><strong>System Monitoring</strong>: Real-time system metrics and health</li>
<li><strong>Tenant Management</strong>: Tenant-specific metrics and configuration</li>
<li><strong>Policy Management</strong>: Rate limiting policy configuration</li>
<li><strong>Troubleshooting</strong>: Debug and diagnostic tools</li>
<li><strong>Reporting</strong>: Generate reports and analytics</li></p><p>#### Architecture
<pre><code>// React Component Structure
interface AdminUIProps {
  apiClient: APIClient;
  config: UIConfig;
}</p><p>// Main Application Structure
const AdminUI: React.FC<AdminUIProps> = ({ apiClient, config }) => {
  return (
    <Router>
      <Layout>
        <Sidebar />
        <MainContent>
          <Routes>
            <Route path="/" element={<Overview />} />
            <Route path="/tenants" element={<Tenants />} />
            <Route path="/tenants/:id" element={<TenantDetails />} />
            <Route path="/system" element={<SystemHealth />} />
            <Route path="/wiki" element={<Wiki />} />
          </Routes>
        </MainContent>
      </Layout>
    </Router>
  );
};
</code></pre></p><p>#### Key Features
<li><strong>Real-time Updates</strong>: Live metrics and status updates</li>
<li><strong>Interactive Dashboards</strong>: Rich, interactive dashboards</li>
<li><strong>Responsive Design</strong>: Mobile-friendly interface</li>
<li><strong>Search and Filtering</strong>: Advanced search and filtering capabilities</li>
<li><strong>Export Functionality</strong>: Export data and reports</li></p><p>#### Performance Characteristics
<li><strong>Load Time</strong>: <2 seconds initial load</li>
<li><strong>Update Frequency</strong>: 5-second refresh intervals</li>
<li><strong>Memory</strong>: <200MB browser memory usage</li>
<li><strong>Responsiveness</strong>: <100ms UI interactions</li></p><p><h3>6. Mimir Distributor</h3></p><p>#### Purpose
The Mimir Distributor is the target service that receives metrics after rate limiting decisions are made.</p><p>#### Responsibilities
<li><strong>Metrics Ingestion</strong>: Receive and process metrics</li>
<li><strong>Data Distribution</strong>: Distribute data to storage backends</li>
<li><strong>Validation</strong>: Validate incoming metrics</li>
<li><strong>Compression</strong>: Handle compressed metric data</li>
<li><strong>Authentication</strong>: Authenticate incoming requests</li></p><p>#### Integration Points
<pre><code><h1>Integration with Edge Enforcement</h1>
integration:
  upstream: distributor.mimir.svc.cluster.local:8080
  protocol: HTTP/2
  authentication: Bearer token
  compression: gzip, snappy
  
<h1>Rate Limiting Headers</h1>
headers:
  - X-Edge-Enforcement: selective|none
  - X-Route-Decision: edge|direct
  - X-Tenant-ID: <tenant_id>
  - X-Rate-Limited: true|false
</code></pre></p><p><h2>Component Interactions</h2></p><p><h3>1. Request Flow</h3></p><p>#### Normal Request Flow
<pre><code>sequenceDiagram
    participant Client
    participant NGINX
    participant RLS
    participant Envoy
    participant Distributor
    
    Client->>NGINX: POST /api/v1/push
    NGINX->>NGINX: Determine route based on user
    alt Route to Edge Enforcement
        NGINX->>RLS: Forward request
        RLS->>RLS: Check rate limits
        RLS->>Envoy: Forward if allowed
        Envoy->>Distributor: Forward to distributor
    else Route Directly
        NGINX->>Distributor: Forward directly
    end
    Distributor->>Client: Response
</code></pre></p><p>#### Rate Limited Request Flow
<pre><code>sequenceDiagram
    participant Client
    participant NGINX
    participant RLS
    
    Client->>NGINX: POST /api/v1/push
    NGINX->>RLS: Forward request
    RLS->>RLS: Check rate limits
    RLS->>RLS: Rate limit exceeded
    RLS->>Client: 429 Too Many Requests
</code></pre></p><p><h3>2. Configuration Flow</h3></p><p>#### Dynamic Configuration Update
<pre><code>sequenceDiagram
    participant Admin
    participant Controller
    participant K8s
    participant RLS
    
    Admin->>Controller: Update configuration
    Controller->>K8s: Update ConfigMap
    K8s->>Controller: ConfigMap updated
    Controller->>RLS: Sync configuration
    RLS->>RLS: Apply new configuration
    RLS->>Admin: Configuration applied
</code></pre></p><p><h3>3. Monitoring Flow</h3></p><p>#### Metrics Collection
<pre><code>sequenceDiagram
    participant RLS
    participant Prometheus
    participant Grafana
    participant Admin
    
    RLS->>RLS: Collect metrics
    RLS->>Prometheus: Expose metrics
    Prometheus->>Prometheus: Scrape metrics
    Prometheus->>Grafana: Provide metrics
    Grafana->>Grafana: Create dashboards
    Admin->>RLS: Fetch metrics via API
    Admin->>Admin: Display in UI
</code></pre></p><p><h2>Design Patterns</h2></p><p><h3>1. Microservices Architecture</h3></p><p>#### Benefits
<li><strong>Independent Deployment</strong>: Each component can be deployed independently</li>
<li><strong>Technology Diversity</strong>: Different components can use different technologies</li>
<li><strong>Scalability</strong>: Components can be scaled independently</li>
<li><strong>Fault Isolation</strong>: Failures in one component don't affect others</li></p><p>#### Implementation
<pre><code><h1>Service Independence</h1>
services:
  nginx:
    deployment: independent
    scaling: horizontal
    technology: nginx
    
  rls:
    deployment: independent
    scaling: horizontal
    technology: golang
    
  envoy:
    deployment: independent
    scaling: horizontal
    technology: envoy
    
  admin-ui:
    deployment: independent
    scaling: horizontal
    technology: react
</code></pre></p><p><h3>2. Event-Driven Architecture</h3></p><p>#### Benefits
<li><strong>Loose Coupling</strong>: Components communicate through events</li>
<li><strong>Scalability</strong>: Easy to add new event consumers</li>
<li><strong>Reliability</strong>: Event persistence and replay capabilities</li>
<li><strong>Flexibility</strong>: Dynamic event routing and filtering</li></p><p>#### Implementation
<pre><code>// Event Structure
type Event struct {
    ID        string                 <code>json:"id"</code>
    Type      string                 <code>json:"type"</code>
    Timestamp time.Time              <code>json:"timestamp"</code>
    Data      map[string]interface{} <code>json:"data"</code>
    Source    string                 <code>json:"source"</code>
}</p><p>// Event Types
const (
    EventRateLimitExceeded = "rate_limit_exceeded"
    EventTenantCreated     = "tenant_created"
    EventConfigUpdated     = "config_updated"
    EventHealthCheck       = "health_check"
)
</code></pre></p><p><h3>3. Circuit Breaker Pattern</h3></p><p>#### Benefits
<li><strong>Fault Tolerance</strong>: Prevent cascading failures</li>
<li><strong>Performance</strong>: Fail fast when services are unavailable</li>
<li><strong>Recovery</strong>: Automatic recovery when services become available</li>
<li><strong>Monitoring</strong>: Clear visibility into service health</li></p><p>#### Implementation
<pre><code>// Circuit Breaker States
type CircuitBreakerState int</p><p>const (
    StateClosed CircuitBreakerState = iota
    StateOpen
    StateHalfOpen
)</p><p>// Circuit Breaker Implementation
type CircuitBreaker struct {
    state       CircuitBreakerState
    failureCount int
    threshold   int
    timeout     time.Duration
    lastFailure time.Time
    mutex       sync.RWMutex
}
</code></pre></p><p><h3>4. Observer Pattern</h3></p><p>#### Benefits
<li><strong>Loose Coupling</strong>: Observers don't depend on subject implementation</li>
<li><strong>Dynamic Registration</strong>: Observers can be added/removed at runtime</li>
<li><strong>Event Broadcasting</strong>: Multiple observers can receive the same event</li>
<li><strong>Extensibility</strong>: Easy to add new observers</li></p><p>#### Implementation
<pre><code>// Observer Interface
type Observer interface {
    Update(event Event)
}</p><p>// Subject Interface
type Subject interface {
    Attach(observer Observer)
    Detach(observer Observer)
    Notify(event Event)
}</p><p>// RLS as Subject
type RateLimitService struct {
    observers []Observer
    mutex     sync.RWMutex
}
</code></pre></p><p><h2>Performance Considerations</h2></p><p><h3>1. Caching Strategy</h3></p><p>#### Multi-Level Caching
<pre><code><h1>Cache Levels</h1>
caching:
  level_1:
    type: in_memory
    location: process
    size: 100MB
    ttl: 1 minute
    
  level_2:
    type: redis
    location: external
    size: 1GB
    ttl: 10 minutes
    
  level_3:
    type: database
    location: persistent
    size: unlimited
    ttl: 1 hour
</code></pre></p><p>#### Cache Invalidation
<pre><code>// Cache Invalidation Strategy
type CacheManager struct {
    caches map[string]Cache
    invalidationRules map[string][]InvalidationRule
}</p><p>type InvalidationRule struct {
    Pattern string
    TTL     time.Duration
    Priority int
}
</code></pre></p><p><h3>2. Connection Pooling</h3></p><p>#### Database Connections
<pre><code>// Connection Pool Configuration
type DBConfig struct {
    MaxOpenConns    int           <code>yaml:"max_open_conns"</code>
    MaxIdleConns    int           <code>yaml:"max_idle_conns"</code>
    ConnMaxLifetime time.Duration <code>yaml:"conn_max_lifetime"</code>
    ConnMaxIdleTime time.Duration <code>yaml:"conn_max_idle_time"</code>
}
</code></pre></p><p>#### HTTP Client Pooling
<pre><code>// HTTP Client Configuration
type HTTPClientConfig struct {
    MaxIdleConns        int           <code>yaml:"max_idle_conns"</code>
    MaxIdleConnsPerHost int           <code>yaml:"max_idle_conns_per_host"</code>
    IdleConnTimeout     time.Duration <code>yaml:"idle_conn_timeout"</code>
    DisableCompression  bool          <code>yaml:"disable_compression"</code>
}
</code></pre></p><p><h3>3. Async Processing</h3></p><p>#### Background Workers
<pre><code>// Worker Pool
type WorkerPool struct {
    workers    int
    jobQueue   chan Job
    resultChan chan Result
    wg         sync.WaitGroup
}</p><p>// Job Processing
func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workers; i++ {
        wp.wg.Add(1)
        go wp.worker()
    }
}
</code></pre></p><p><h2>Security Considerations</h2></p><p><h3>1. Authentication and Authorization</h3></p><p>#### Multi-Factor Authentication
<pre><code><h1>Authentication Methods</h1>
authentication:
  methods:
    - type: bearer_token
      provider: kubernetes
      
    - type: oauth2
      provider: google
      
    - type: saml
      provider: okta
</code></pre></p><p>#### Role-Based Access Control
<pre><code><h1>RBAC Configuration</h1>
rbac:
  roles:
    - name: admin
      permissions:
        - "*"
        
    - name: operator
      permissions:
        - "read:metrics"
        - "write:config"
        
    - name: viewer
      permissions:
        - "read:metrics"
</code></pre></p><p><h3>2. Data Protection</h3></p><p>#### Encryption at Rest
<pre><code><h1>Encryption Configuration</h1>
encryption:
  at_rest:
    algorithm: AES-256-GCM
    key_rotation: 90 days
    
  in_transit:
    protocol: TLS 1.3
    cipher_suites:
      - TLS_AES_256_GCM_SHA384
      - TLS_CHACHA20_POLY1305_SHA256
</code></pre></p><p>#### Data Masking
<pre><code>// Sensitive Data Masking
type DataMasker struct {
    patterns []regexp.Regexp
    masks    map[string]string
}</p><p>func (dm *DataMasker) Mask(data []byte) []byte {
    // Implementation for masking sensitive data
}
</code></pre></p><p><h2>Conclusion</h2></p><p>The Mimir Edge Enforcement system employs a well-architected, microservices-based design that provides:</p><p><li><strong>Scalability</strong>: Each component can be scaled independently</li>
<li><strong>Reliability</strong>: Fault isolation and circuit breaker patterns</li>
<li><strong>Performance</strong>: Optimized for low latency and high throughput</li>
<li><strong>Security</strong>: Comprehensive security measures at all layers</li>
<li><strong>Observability</strong>: Rich monitoring and debugging capabilities</li></p><p>The component architecture ensures that the system can handle the demanding requirements of modern observability environments while maintaining operational simplicity and cost-effectiveness.</p><p>---</p><p><strong>Next Steps</strong>:
<li>Review deployment strategies in <code>deployment/deployment-strategy.md</code></li>
<li>Explore monitoring and observability in <code>monitoring/monitoring-strategy.md</code></li>
<li>Understand security architecture in <code>security/security-architecture.md</code></li>
<li>Learn about performance characteristics in <code>performance/performance-characteristics.md</code></li></p><p><strong>Related Documents</strong>:
<li>[System Architecture](system-architecture.md)</li>
<li>[Rate Limit Service](../components/rate-limit-service.md)</li>
<li>[Deployment Strategy](../deployment/deployment-strategy.md)</li>
<li>[Security Architecture](../security/security-architecture.md)</li></p><p>---</p><p>
<h2>Rate Limit Service (RLS)</h2></p><p>
<h2>Overview</h2></p><p>The Rate Limit Service (RLS) is the core enforcement engine of the Mimir Edge Enforcement system. It provides authorization and rate limiting decisions through gRPC and HTTP APIs, with comprehensive monitoring and management capabilities.</p><p><h2>Architecture</h2></p><p><h3>Service Architecture Diagram</h3></p><p><pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                            Rate Limit Service (RLS)                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                              API Layer                                     ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   gRPC      ‚îÇ  ‚îÇ   gRPC      ‚îÇ  ‚îÇ   HTTP      ‚îÇ  ‚îÇ   HTTP      ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ext_authz   ‚îÇ  ‚îÇ ratelimit   ‚îÇ  ‚îÇ   Admin     ‚îÇ  ‚îÇ   Health    ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Server    ‚îÇ  ‚îÇ   Server    ‚îÇ  ‚îÇ    API      ‚îÇ  ‚îÇ   Check     ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                    ‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                           Request Processing                               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Tenant    ‚îÇ  ‚îÇ   Body      ‚îÇ  ‚îÇ   Limit     ‚îÇ  ‚îÇ   Token     ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ     ID      ‚îÇ  ‚îÇ  Parsing    ‚îÇ  ‚îÇ   Check     ‚îÇ  ‚îÇ  Bucket     ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Extraction  ‚îÇ  ‚îÇ(Protobuf)   ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ Algorithm   ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                    ‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                            State Management                                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Tenant    ‚îÇ  ‚îÇ   Token     ‚îÇ  ‚îÇ   Time      ‚îÇ  ‚îÇ   Cache     ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Limits    ‚îÇ  ‚îÇ  Buckets    ‚îÇ  ‚îÇAggregator   ‚îÇ  ‚îÇ  System     ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                    ‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                            Observability                                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Prometheus  ‚îÇ  ‚îÇ Structured  ‚îÇ  ‚îÇ   Health    ‚îÇ  ‚îÇ   Metrics   ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Metrics   ‚îÇ  ‚îÇ   Logging   ‚îÇ  ‚îÇ   Checks    ‚îÇ  ‚îÇ  Collection ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></p><p><h3>Component Interaction Flow</h3></p><p><pre><code>graph TB
    A[Request] --> B[API Layer]
    B --> C[Request Processing]
    C --> D[Tenant ID Extraction]
    C --> E[Body Parsing]
    C --> F[Limit Check]
    C --> G[Token Bucket]
    D --> H[State Management]
    E --> H
    F --> H
    G --> H
    H --> I[Decision]
    I --> J[Response]
    H --> K[Observability]
    K --> L[Metrics]
    K --> M[Logging]
    K --> N[Health Checks]
</code></pre></p><p><h2>API Services</h2></p><p><h3>1. gRPC ext_authz Server</h3></p><p>#### Purpose
Provides external authorization decisions for Envoy's ext_authz filter.</p><p>#### Protocol
<li><strong>Service</strong>: <code>envoy.service.auth.v3.Authorization</code></li>
<li><strong>Method</strong>: <code>Check</code></li>
<li><strong>Port</strong>: 8081 (default)</li></p><p>#### Request Flow
<pre><code>func (rls <em>RLS) Check(ctx context.Context, req </em>envoy_service_auth_v3.CheckRequest) (*envoy_service_auth_v3.CheckResponse, error) {
    // 1. Extract tenant ID from request
    tenantID := rls.extractTenantID(req)
    
    // 2. Parse request body (protobuf)
    body, err := rls.parseRequestBody(req)
    if err != nil {
        return rls.createDenyResponse("body_parse_error"), nil
    }
    
    // 3. Check tenant limits
    decision := rls.checkLimits(tenantID, body)
    
    // 4. Record decision for metrics
    rls.recordDecision(tenantID, decision.Allowed, decision.Reason, body.Samples, body.Bytes, nil, nil, nil)
    
    // 5. Return response
    if decision.Allowed {
        return rls.createAllowResponse(), nil
    }
    return rls.createDenyResponse(decision.Reason), nil
}
</code></pre></p><p>#### Configuration
<pre><code><h1>Envoy ext_authz filter configuration</h1>
http_filters:
<li>name: envoy.filters.http.ext_authz</li>
  typed_config:
    "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
    with_request_body:
      max_request_bytes: 52428800  # 50MB
    failure_mode_allow: false
    grpc_service:
      envoy_grpc:
        cluster_name: rls_ext_authz
</code></pre></p><p><h3>2. gRPC ratelimit Server</h3></p><p>#### Purpose
Provides rate limiting decisions for Envoy's rate_limit filter.</p><p>#### Protocol
<li><strong>Service</strong>: <code>envoy.service.ratelimit.v3.RateLimitService</code></li>
<li><strong>Method</strong>: <code>ShouldRateLimit</code></li>
<li><strong>Port</strong>: 8083 (default)</li></p><p>#### Request Flow
<pre><code>func (rls <em>RLS) ShouldRateLimit(ctx context.Context, req </em>envoy_service_ratelimit_v3.RateLimitRequest) (*envoy_service_ratelimit_v3.RateLimitResponse, error) {
    // 1. Extract tenant ID from descriptors
    tenantID := rls.extractTenantIDFromDescriptors(req.Descriptors)
    
    // 2. Check token bucket for rate limiting
    allowed := rls.checkRateLimit(tenantID, req)
    
    // 3. Return rate limit response
    if allowed {
        return &envoy_service_ratelimit_v3.RateLimitResponse{
            OverallCode: envoy_service_ratelimit_v3.RateLimitResponse_OK,
        }, nil
    }
    
    return &envoy_service_ratelimit_v3.RateLimitResponse{
        OverallCode: envoy_service_ratelimit_v3.RateLimitResponse_OVER_LIMIT,
    }, nil
}
</code></pre></p><p>#### Configuration
<pre><code><h1>Envoy rate_limit filter configuration</h1>
http_filters:
<li>name: envoy.filters.http.ratelimit</li>
  typed_config:
    "@type": type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit
    domain: mimir_remote_write
    rate_limit_service:
      grpc_service:
        envoy_grpc:
          cluster_name: rls_ratelimit
</code></pre></p><p><h3>3. HTTP Admin API</h3></p><p>#### Purpose
Provides management and monitoring capabilities through REST API.</p><p>#### Endpoints
<pre><code><h1>Overview and System Metrics</h1>
GET /api/overview?range=1h
GET /api/system/status
GET /api/health</p><p><h1>Tenant Management</h1>
GET /api/tenants?range=1h
GET /api/tenants/{id}?range=24h
PUT /api/tenants/{id}/limits
POST /api/tenants/{id}/enforcement</p><p><h1>Denials and Monitoring</h1>
GET /api/denials
GET /api/denials/enhanced
GET /api/denials/trends</p><p><h1>Cardinality Management</h1>
GET /api/cardinality
GET /api/cardinality/violations
GET /api/cardinality/trends</p><p><h1>Traffic Flow</h1>
GET /api/traffic/flow
GET /api/flow/status
GET /api/timeseries/{timeRange}/flow</p><p><h1>Debug and Testing</h1>
GET /api/debug/routes
GET /api/debug/tenants
POST /api/debug/add-test-data
</code></pre></p><p>#### Port Configuration
<li><strong>Admin API</strong>: 8082 (default)</li>
<li><strong>Metrics</strong>: 9090 (default)</li>
<li><strong>Health Check</strong>: 8082/health</li></p><p><h2>Request Processing</h2></p><p><h3>1. Tenant ID Extraction</h3></p><p>#### Methods
<li><strong>HTTP Header</strong>: <code>X-Scope-OrgID</code> (default)</li>
<li><strong>Configurable</strong>: Custom header support</li>
<li><strong>Validation</strong>: Header presence and format</li></p><p>#### Implementation
<pre><code>func (rls <em>RLS) extractTenantID(req </em>envoy_service_auth_v3.CheckRequest) string {
    // Extract from HTTP headers
    if req.Attributes.Request.Http != nil {
        for _, header := range req.Attributes.Request.Http.Headers {
            if header.Key == rls.config.TenantHeader {
                return header.Value
            }
        }
    }
    
    // Return default tenant if not found
    return "default"
}
</code></pre></p><p><h3>2. Body Parsing</h3></p><p>#### Protobuf Parsing
<li><strong>Format</strong>: Prometheus remote write protobuf</li>
<li><strong>Compression</strong>: gzip, snappy, uncompressed</li>
<li><strong>Validation</strong>: Size limits and format validation</li></p><p>#### Implementation
<pre><code>func (rls <em>RLS) parseRequestBody(req </em>envoy_service_auth_v3.CheckRequest) (*RequestInfo, error) {
    // Get request body
    body := req.Attributes.Request.Http.Body
    
    // Check size limits
    if len(body) > rls.config.MaxRequestBytes {
        return nil, fmt.Errorf("request body too large: %d bytes", len(body))
    }
    
    // Parse protobuf
    var writeRequest prompb.WriteRequest
    if err := proto.Unmarshal(body, &writeRequest); err != nil {
        return nil, fmt.Errorf("failed to parse protobuf: %w", err)
    }
    
    // Extract metrics
    info := &RequestInfo{
        Samples: int64(len(writeRequest.Timeseries)),
        Bytes:   int64(len(body)),
    }
    
    // Calculate series and labels
    for _, ts := range writeRequest.Timeseries {
        info.ObservedSeries++
        info.ObservedLabels += int64(len(ts.Labels))
    }
    
    return info, nil
}
</code></pre></p><p><h3>3. Limit Checking</h3></p><p>#### Limit Types
<li><strong>Samples per Second</strong>: Rate limiting for samples</li>
<li><strong>Max Body Bytes</strong>: Request size limits</li>
<li><strong>Max Series per Request</strong>: Cardinality limits</li>
<li><strong>Max Labels per Series</strong>: Label count limits</li></p><p>#### Implementation
<pre><code>func (rls <em>RLS) checkLimits(tenantID string, info </em>RequestInfo) limits.Decision {
    // Get tenant state
    tenant := rls.getTenant(tenantID)
    
    // Check samples per second
    if tenant.Info.Enforcement.EnforceSamplesPerSecond {
        if !tenant.SamplesBucket.Take(float64(info.Samples)) {
            return limits.Decision{
                Allowed: false,
                Reason:  "samples_per_second_exceeded",
                Code:    429,
            }
        }
    }
    
    // Check body size
    if tenant.Info.Enforcement.EnforceMaxBodyBytes {
        if info.Bytes > tenant.Info.Limits.MaxBodyBytes {
            return limits.Decision{
                Allowed: false,
                Reason:  "max_body_bytes_exceeded",
                Code:    413,
            }
        }
    }
    
    // Check series limits
    if tenant.Info.Enforcement.EnforceMaxSeriesPerRequest {
        if info.ObservedSeries > tenant.Info.Limits.MaxSeriesPerRequest {
            return limits.Decision{
                Allowed: false,
                Reason:  "max_series_per_request_exceeded",
                Code:    429,
            }
        }
    }
    
    return limits.Decision{
        Allowed: true,
        Reason:  "allowed",
        Code:    200,
    }
}
</code></pre></p><p><h2>State Management</h2></p><p><h3>1. Tenant Limits</h3></p><p>#### Data Structure
<pre><code>type TenantLimits struct {
    SamplesPerSecond    float64 <code>json:"samples_per_second"</code>
    MaxBodyBytes        int64   <code>json:"max_body_bytes"</code>
    MaxSeriesPerRequest int64   <code>json:"max_series_per_request"</code>
    MaxLabelsPerSeries  int64   <code>json:"max_labels_per_series"</code>
}</p><p>type EnforcementConfig struct {
    Enabled                        bool <code>json:"enabled"</code>
    EnforceSamplesPerSecond        bool <code>json:"enforce_samples_per_second"</code>
    EnforceMaxBodyBytes            bool <code>json:"enforce_max_body_bytes"</code>
    EnforceMaxSeriesPerRequest     bool <code>json:"enforce_max_series_per_request"</code>
    EnforceMaxLabelsPerSeries      bool <code>json:"enforce_max_labels_per_series"</code>
}
</code></pre></p><p>#### Storage
<li><strong>Primary</strong>: In-memory map</li>
<li><strong>Key</strong>: Tenant ID</li>
<li><strong>Value</strong>: TenantState with limits and buckets</li>
<li><strong>Persistence</strong>: Optional Redis backend</li></p><p><h3>2. Token Buckets</h3></p><p>#### Algorithm
<li><strong>Type</strong>: Token bucket algorithm</li>
<li><strong>Refill Rate</strong>: Based on tenant limits</li>
<li><strong>Capacity</strong>: Configurable burst capacity</li>
<li><strong>Thread Safety</strong>: Concurrent access support</li></p><p>#### Implementation
<pre><code>type TokenBucket struct {
    mu       sync.Mutex
    tokens   float64
    capacity float64
    rate     float64
    lastRefill time.Time
}</p><p>func (tb *TokenBucket) Take(tokens float64) bool {
    tb.mu.Lock()
    defer tb.mu.Unlock()
    
    // Refill tokens
    now := time.Now()
    elapsed := now.Sub(tb.lastRefill).Seconds()
    tb.tokens = math.Min(tb.capacity, tb.tokens + elapsed * tb.rate)
    tb.lastRefill = now
    
    // Check if enough tokens
    if tb.tokens >= tokens {
        tb.tokens -= tokens
        return true
    }
    
    return false
}
</code></pre></p><p><h3>3. Time-Based Aggregation</h3></p><p>#### Bucket Types
<li><strong>15-minute buckets</strong>: Short-term analysis</li>
<li><strong>1-hour buckets</strong>: Operational monitoring</li>
<li><strong>24-hour buckets</strong>: Daily trends</li>
<li><strong>1-week buckets</strong>: Long-term planning</li></p><p>#### Implementation
<pre><code>type TimeBucket struct {
    StartTime         time.Time
    EndTime           time.Time
    TotalRequests     int64
    AllowedRequests   int64
    DeniedRequests    int64
    TotalSeries       int64
    TotalLabels       int64
    Violations        int64
    AvgResponseTime   float64
    MaxResponseTime   float64
    MinResponseTime   float64
    ResponseTimeCount int64
}</p><p>type TimeAggregator struct {
    mu sync.RWMutex
    buckets15min map[string]*TimeBucket
    buckets1h    map[string]*TimeBucket
    buckets24h   map[string]*TimeBucket
    buckets1w    map[string]*TimeBucket
}
</code></pre></p><p><h3>4. Caching System</h3></p><p>#### Cache Types
<li><strong>Overview Cache</strong>: System-wide metrics</li>
<li><strong>Tenant Cache</strong>: Per-tenant metrics</li>
<li><strong>Configuration Cache</strong>: Tenant limits and settings</li></p><p>#### Implementation
<pre><code>type Cache struct {
    mu    sync.RWMutex
    data  map[string]cacheEntry
    ttl   time.Duration
}</p><p>type cacheEntry struct {
    data      interface{}
    timestamp time.Time
    ttl       time.Duration
}</p><p>func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    entry, exists := c.data[key]
    if !exists {
        return nil, false
    }
    
    if time.Since(entry.timestamp) > entry.ttl {
        return nil, false
    }
    
    return entry.data, true
}
</code></pre></p><p><h2>Observability</h2></p><p><h3>1. Prometheus Metrics</h3></p><p>#### Core Metrics
<pre><code><h1>Authorization decisions</h1>
rls_decisions_total{decision="allow|deny", tenant="tenant-id", reason="reason"}</p><p><h1>Performance</h1>
rls_authz_check_duration_seconds_bucket
rls_body_parse_duration_seconds_bucket</p><p><h1>Errors</h1>
rls_body_parse_errors_total
rls_limits_stale_seconds</p><p><h1>Token bucket states</h1>
rls_tenant_bucket_tokens{tenant="tenant-id", bucket_type="samples|bytes|requests"}</p><p><h1>Time-based aggregation</h1>
rls_time_aggregator_buckets_total{time_range="1h"}
rls_cache_hits_total{cache_type="overview|tenants"}
</code></pre></p><p>#### Metric Collection
<pre><code>type Metrics struct {
    DecisionsTotal           *prometheus.CounterVec
    AuthzCheckDuration       *prometheus.HistogramVec
    BodyParseDuration        *prometheus.HistogramVec
    BodyParseErrorsTotal     *prometheus.CounterVec
    LimitsStaleSeconds       *prometheus.GaugeVec
    TenantBucketTokens       *prometheus.GaugeVec
    TimeAggregatorBuckets    *prometheus.GaugeVec
    CacheHitsTotal           *prometheus.CounterVec
}
</code></pre></p><p><h3>2. Structured Logging</h3></p><p>#### Log Format
<pre><code>{
  "level": "info",
  "time": "2024-01-15T10:30:00Z",
  "tenant": "tenant-1",
  "decision": "deny",
  "reason": "samples_per_second_exceeded",
  "observed_samples": 15000,
  "limit": 10000,
  "request_id": "req-12345",
  "duration_ms": 2.5
}
</code></pre></p><p>#### Logging Implementation
<pre><code>func (rls <em>RLS) recordDecision(tenantID string, allowed bool, reason string, samples, bytes int64, requestInfo </em>limits.RequestInfo, sampleMetrics []limits.SampleMetric, parseInfo *limits.ParseInfo) {
    rls.logger.Info().
        Str("tenant", tenantID).
        Bool("decision", allowed).
        Str("reason", reason).
        Int64("observed_samples", samples).
        Int64("observed_bytes", bytes).
        Interface("request_info", requestInfo).
        Interface("sample_metrics", sampleMetrics).
        Interface("parse_info", parseInfo).
        Msg("RLS decision recorded")
}
</code></pre></p><p><h3>3. Health Checks</h3></p><p>#### Health Endpoints
<pre><code><h1>Basic health check</h1>
GET /api/health</p><p><h1>Detailed health check</h1>
GET /api/system/status</p><p><h1>Component health</h1>
GET /api/flow/status
</code></pre></p><p>#### Health Check Implementation
<pre><code>func (rls <em>RLS) healthCheck(w http.ResponseWriter, r </em>http.Request) {
    status := map[string]interface{}{
        "status": "healthy",
        "timestamp": time.Now().Format(time.RFC3339),
        "version": rls.version,
        "uptime": time.Since(rls.startTime).String(),
    }
    
    // Check critical components
    if !rls.checkCriticalComponents() {
        status["status"] = "unhealthy"
        w.WriteHeader(http.StatusServiceUnavailable)
    }
    
    writeJSON(w, http.StatusOK, status)
}
</code></pre></p><p><h2>Configuration</h2></p><p><h3>1. Environment Variables</h3></p><p>#### Core Configuration
<pre><code><h1>Service Configuration</h1>
MAX_REQUEST_BYTES=52428800
TENANT_HEADER=X-Scope-OrgID
FAILURE_MODE_ALLOW=false</p><p><h1>Default Limits</h1>
DEFAULT_SAMPLES_PER_SECOND=10000
DEFAULT_MAX_BODY_BYTES=52428800
DEFAULT_MAX_SERIES_PER_REQUEST=1000000
DEFAULT_MAX_LABELS_PER_SERIES=30</p><p><h1>Redis Configuration (optional)</h1>
REDIS_ADDRESS=redis:6379
REDIS_POOL_SIZE=200
REDIS_MIN_IDLE_CONNS=50</p><p><h1>Logging Configuration</h1>
LOG_LEVEL=info
LOG_FORMAT=json
</code></pre></p><p><h3>2. Kubernetes Configuration</h3></p><p>#### Deployment Configuration
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: mimir-rls
spec:
  replicas: 10
  selector:
    matchLabels:
      app: mimir-rls
  template:
    spec:
      containers:
      - name: rls
        image: mimir-rls:latest
        ports:
        - containerPort: 8081  # gRPC ext_authz
        - containerPort: 8082  # HTTP admin
        - containerPort: 8083  # gRPC ratelimit
        - containerPort: 9090  # Metrics
        env:
        - name: MAX_REQUEST_BYTES
          value: "52428800"
        - name: TENANT_HEADER
          value: "X-Scope-OrgID"
        resources:
          requests:
            memory: 8Gi
            cpu: 1000m
          limits:
            memory: 16Gi
            cpu: 4000m
</code></pre></p><p><h2>Performance Characteristics</h2></p><p><h3>1. Latency Impact</h3></p><p>#### Request Processing Latency
<li><strong>Tenant ID Extraction</strong>: ~0.1ms</li>
<li><strong>Body Parsing</strong>: ~0.5-2ms (depending on size)</li>
<li><strong>Limit Checking</strong>: ~0.1-1ms</li>
<li><strong>Token Bucket Operations</strong>: ~0.1ms</li>
<li><strong>Total Overhead</strong>: ~1-5ms per request</li></p><p>#### Optimization Techniques
<li><strong>Connection Pooling</strong>: HTTP/2 connection reuse</li>
<li><strong>Memory Pooling</strong>: Efficient memory allocation</li>
<li><strong>Concurrent Processing</strong>: Goroutine-based request handling</li>
<li><strong>Caching</strong>: Intelligent caching strategies</li></p><p><h3>2. Throughput</h3></p><p>#### Performance Benchmarks
<li><strong>Requests per Second</strong>: 10,000+ per instance</li>
<li><strong>Concurrent Connections</strong>: 1,000+ per instance</li>
<li><strong>Memory Usage</strong>: ~100-500MB per instance</li>
<li><strong>CPU Usage</strong>: ~0.1-1 CPU core per instance</li></p><p>#### Scaling Characteristics
<li><strong>Horizontal Scaling</strong>: Linear scaling with replicas</li>
<li><strong>Load Distribution</strong>: Round-robin with health checks</li>
<li><strong>State Sharing</strong>: Optional Redis backend for shared state</li>
<li><strong>Auto-scaling</strong>: HPA with CPU/memory targets</li></p><p><h3>3. Resource Usage</h3></p><p>#### Memory Management
<li><strong>In-Memory State</strong>: ~50-200MB per tenant</li>
<li><strong>Token Buckets</strong>: ~1KB per tenant</li>
<li><strong>Time Aggregator</strong>: ~10-50MB total</li>
<li><strong>Cache System</strong>: ~10-100MB total</li></p><p>#### CPU Optimization
<li><strong>Goroutine Pool</strong>: Efficient concurrency</li>
<li><strong>Lock-Free Operations</strong>: Where possible</li>
<li><strong>Batch Processing</strong>: Request batching</li>
<li><strong>Profiling</strong>: Regular performance profiling</li></p><p><h2>Security Considerations</h2></p><p><h3>1. Authentication & Authorization</h3></p><p>#### Service Authentication
<li><strong>gRPC</strong>: mTLS for inter-service communication</li>
<li><strong>HTTP</strong>: Bearer tokens for admin API</li>
<li><strong>Kubernetes</strong>: Service accounts and RBAC</li></p><p>#### Tenant Authentication
<li><strong>Header Validation</strong>: Tenant ID header validation</li>
<li><strong>Rate Limiting</strong>: Per-tenant rate limiting</li>
<li><strong>Access Control</strong>: Tenant isolation</li></p><p><h3>2. Data Protection</h3></p><p>#### Request Body Handling
<li><strong>Size Limits</strong>: Configurable request size limits</li>
<li><strong>Parsing Validation</strong>: Protobuf format validation</li>
<li><strong>No Persistence</strong>: In-memory only, no disk storage</li>
<li><strong>Logging</strong>: No sensitive data in logs</li></p><p>#### Metrics & Logging
<li><strong>Tenant Context</strong>: Tenant ID in all metrics</li>
<li><strong>Privacy</strong>: No sensitive data exposure</li>
<li><strong>Audit Trail</strong>: Complete request audit trail</li>
<li><strong>Retention</strong>: Configurable retention policies</li></p><p><h2>Troubleshooting</h2></p><p><h3>1. Common Issues</h3></p><p>#### High Latency
<strong>Symptoms</strong>: Increased request latency
<strong>Causes</strong>:
<li>High CPU usage</li>
<li>Memory pressure</li>
<li>Network issues</li>
<li>Token bucket contention</li></p><p><strong>Solutions</strong>:
<pre><code><h1>Check resource usage</h1>
kubectl top pods -n mimir-edge-enforcement</p><p><h1>Check metrics</h1>
curl http://localhost:9090/metrics | grep rls_authz_check_duration</p><p><h1>Scale up replicas</h1>
kubectl scale deployment mimir-rls --replicas=20
</code></pre></p><p>#### Memory Issues
<strong>Symptoms</strong>: High memory usage or OOM kills
<strong>Causes</strong>:
<li>Too many tenants</li>
<li>Large request bodies</li>
<li>Memory leaks</li>
<li>Inefficient caching</li></p><p><strong>Solutions</strong>:
<pre><code><h1>Check memory usage</h1>
kubectl top pods -n mimir-edge-enforcement</p><p><h1>Check tenant count</h1>
curl http://localhost:8082/api/tenants | jq '.tenants | length'</p><p><h1>Increase memory limits</h1>
kubectl patch deployment mimir-rls -p '{"spec":{"template":{"spec":{"containers":[{"name":"rls","resources":{"limits":{"memory":"32Gi"}}}]}}}}'
</code></pre></p><p><h3>2. Debug Procedures</h3></p><p>#### Enable Debug Logging
<pre><code><h1>Update deployment with debug logging</h1>
kubectl patch deployment mimir-rls -p '{"spec":{"template":{"spec":{"containers":[{"name":"rls","env":[{"name":"LOG_LEVEL","value":"debug"}]}]}}}}'
</code></pre></p><p>#### Check Service Health
<pre><code><h1>Basic health check</h1>
curl http://localhost:8082/api/health</p><p><h1>Detailed status</h1>
curl http://localhost:8082/api/system/status</p><p><h1>Component health</h1>
curl http://localhost:8082/api/flow/status
</code></pre></p><p>#### Debug Endpoints
<pre><code><h1>List all routes</h1>
curl http://localhost:8082/api/debug/routes</p><p><h1>Check tenant state</h1>
curl http://localhost:8082/api/debug/tenants</p><p><h1>Add test data</h1>
curl -X POST http://localhost:8082/api/debug/add-test-data
</code></pre></p><p><h2>Future Enhancements</h2></p><p><h3>1. Planned Features</h3></p><p>#### Advanced Rate Limiting
<li><strong>Adaptive Rate Limiting</strong>: Dynamic rate adjustment</li>
<li><strong>Burst Handling</strong>: Improved burst capacity management</li>
<li><strong>Priority Queuing</strong>: Priority-based request handling</li>
<li><strong>Fair Queuing</strong>: Fair resource allocation</li></p><p>#### Enhanced Monitoring
<li><strong>Real-time Dashboards</strong>: Live monitoring dashboards</li>
<li><strong>Predictive Analytics</strong>: Anomaly detection</li>
<li><strong>Custom Alerts</strong>: Tenant-specific alerting</li>
<li><strong>Performance Insights</strong>: Detailed performance analysis</li></p><p><h3>2. Technical Improvements</h3></p><p>#### Performance Optimization
<li><strong>Zero-Copy Parsing</strong>: Efficient protobuf parsing</li>
<li><strong>Memory Pooling</strong>: Advanced memory management</li>
<li><strong>Lock-Free Data Structures</strong>: Improved concurrency</li>
<li><strong>Compression</strong>: Response compression</li></p><p>#### Scalability Enhancements
<li><strong>Distributed State</strong>: Redis-based state sharing</li>
<li><strong>Sharding</strong>: Tenant-based sharding</li>
<li><strong>Caching</strong>: Multi-level caching</li>
<li><strong>Load Balancing</strong>: Advanced load balancing</li></p><p><h2>Conclusion</h2></p><p>The Rate Limit Service (RLS) is the core enforcement engine of the Mimir Edge Enforcement system, providing comprehensive authorization and rate limiting capabilities. With its modular architecture, comprehensive observability, and production-ready features, it delivers reliable and scalable tenant limit enforcement.</p><p>The service's performance characteristics, security features, and troubleshooting capabilities make it suitable for high-scale production environments, while its extensible design supports future enhancements and improvements.</p><p>---</p><p><strong>Next Steps</strong>: Review other component documents for integration details and deployment guides.</p><p>---</p><p>
<h2>Core Features</h2></p><p>
<h2>Overview</h2></p><p>This document provides a comprehensive overview of the core features and capabilities of the Mimir Edge Enforcement system, including detailed explanations, use cases, and implementation details.</p><p><h2>Feature Categories</h2></p><p><h3>1. Rate Limiting and Quota Management</h3></p><p>#### Selective Traffic Routing</p><p><strong>Description</strong>: Intelligent routing of traffic based on user identity, allowing selective application of rate limiting to specific users while bypassing others.</p><p><strong>Implementation</strong>:
<pre><code><h1>NGINX Configuration</h1>
map $remote_user $route_decision {
    "boltx"      "edge";
    "cloudwatch" "edge";
    default      "direct";
}</p><p>location /api/v1/push {
    if ($route_decision = "edge") {
        proxy_pass http://mimir_rls;
        add_header X-Edge-Enforcement "selective";
    }
    if ($route_decision = "direct") {
        proxy_pass http://mimir_direct;
        add_header X-Edge-Enforcement "none";
    }
    add_header X-Route-Decision $route_decision;
}
</code></pre></p><p><strong>Use Cases</strong>:
<li><strong>Cost Control</strong>: Apply rate limiting to high-volume users to control costs</li>
<li><strong>Resource Protection</strong>: Protect critical infrastructure from resource exhaustion</li>
<li><strong>Fair Usage</strong>: Ensure fair resource allocation across tenants</li>
<li><strong>Compliance</strong>: Meet regulatory requirements for resource usage</li></p><p><strong>Benefits</strong>:
<li><strong>Flexibility</strong>: Granular control over which users are rate limited</li>
<li><strong>Transparency</strong>: Clear visibility into routing decisions</li>
<li><strong>Performance</strong>: Minimal overhead for non-rate-limited traffic</li>
<li><strong>Scalability</strong>: Easy to add or remove users from rate limiting</li></p><p>#### Token Bucket Rate Limiting</p><p><strong>Description</strong>: Implementation of the token bucket algorithm for efficient and fair rate limiting with burst support.</p><p><strong>Implementation</strong>:
<pre><code>// Token Bucket Implementation
type TokenBucket struct {
    capacity     int64
    tokens       int64
    refillRate   float64
    lastRefill   time.Time
    mutex        sync.RWMutex
}</p><p>func (tb *TokenBucket) Take(tokens int64) bool {
    tb.mutex.Lock()
    defer tb.mutex.Unlock()
    
    // Refill tokens based on time elapsed
    now := time.Now()
    elapsed := now.Sub(tb.lastRefill).Seconds()
    newTokens := int64(elapsed * tb.refillRate)
    
    if newTokens > 0 {
        tb.tokens = min(tb.capacity, tb.tokens+newTokens)
        tb.lastRefill = now
    }
    
    // Check if enough tokens available
    if tb.tokens >= tokens {
        tb.tokens -= tokens
        return true
    }
    
    return false
}
</code></pre></p><p><strong>Features</strong>:
<li><strong>Burst Support</strong>: Allow temporary bursts above the sustained rate</li>
<li><strong>Fair Distribution</strong>: Ensure fair token distribution across tenants</li>
<li><strong>Configurable Parameters</strong>: Adjustable capacity and refill rates</li>
<li><strong>Real-time Updates</strong>: Dynamic rate limit adjustments</li></p><p><strong>Configuration</strong>:
<pre><code><h1>Rate Limiting Configuration</h1>
rate_limits:
  tenant_default:
    requests_per_second: 1000
    burst_capacity: 2000
    refill_rate: 1000.0
    
  tenant_premium:
    requests_per_second: 5000
    burst_capacity: 10000
    refill_rate: 5000.0
</code></pre></p><p>#### Multi-Tenant Quota Management</p><p><strong>Description</strong>: Comprehensive quota management system that enforces tenant-specific limits on various resources.</p><p><strong>Implementation</strong>:
<pre><code>// Tenant Quota Structure
type TenantQuota struct {
    TenantID           string    <code>json:"tenant_id"</code>
    MaxRequestsPerSec  int64     <code>json:"max_requests_per_sec"</code>
    MaxSamplesPerSec   int64     <code>json:"max_samples_per_sec"</code>
    MaxBytesPerSec     int64     <code>json:"max_bytes_per_sec"</code>
    MaxSeriesPerMetric int64     <code>json:"max_series_per_metric"</code>
    MaxMetricsPerTenant int64    <code>json:"max_metrics_per_tenant"</code>
    SoftLimit          bool      <code>json:"soft_limit"</code>
    HardLimit          bool      <code>json:"hard_limit"</code>
}</p><p>// Quota Enforcement
func (rls <em>RateLimitService) enforceQuota(tenant </em>TenantInfo, request *MetricRequest) error {
    quota := rls.getTenantQuota(tenant.ID)
    
    // Check various quota limits
    if err := rls.checkRequestRate(tenant, quota); err != nil {
        return err
    }
    
    if err := rls.checkSampleRate(tenant, quota); err != nil {
        return err
    }
    
    if err := rls.checkByteRate(tenant, quota); err != nil {
        return err
    }
    
    return nil
}
</code></pre></p><p><strong>Quota Types</strong>:
<li><strong>Request Rate</strong>: Maximum requests per second</li>
<li><strong>Sample Rate</strong>: Maximum samples per second</li>
<li><strong>Byte Rate</strong>: Maximum bytes per second</li>
<li><strong>Series Limit</strong>: Maximum series per metric</li>
<li><strong>Metric Limit</strong>: Maximum metrics per tenant</li></p><p><h3>2. Time-Based Aggregation</h3></p><p>#### Intelligent Metric Aggregation</p><p><strong>Description</strong>: Advanced time-based aggregation system that provides intelligent caching and metric calculation over various time ranges.</p><p><strong>Implementation</strong>:
<pre><code>// Time Aggregator Structure
type TimeAggregator struct {
    windows    map[string]*TimeWindow
    cache      *Cache
    mutex      sync.RWMutex
}</p><p>type TimeWindow struct {
    Start     time.Time
    End       time.Time
    Metrics   map[string]float64
    Count     int64
    LastUpdate time.Time
}</p><p>// Aggregation Methods
func (ta *TimeAggregator) RecordDecision(tenantID string, decision Decision, timestamp time.Time) {
    ta.mutex.Lock()
    defer ta.mutex.Unlock()
    
    // Update all relevant time windows
    for windowKey, window := range ta.windows {
        if timestamp.After(window.Start) && timestamp.Before(window.End) {
            ta.updateWindow(windowKey, tenantID, decision)
        }
    }
}</p><p>func (ta *TimeAggregator) GetTenantAggregatedData(tenantID, timeRange string) map[string]interface{} {
    normalizedRange := ta.normalizeTimeRange(timeRange)
    window := ta.getOrCreateWindow(normalizedRange)
    
    return map[string]interface{}{
        "rps":             ta.calculateRPS(window, tenantID),
        "allow_rate":      ta.calculateAllowRate(window, tenantID),
        "deny_rate":       ta.calculateDenyRate(window, tenantID),
        "samples_per_sec": ta.calculateSamplesPerSec(window, tenantID),
        "bytes_per_sec":   ta.calculateBytesPerSec(window, tenantID),
        "utilization_pct": ta.calculateUtilization(window, tenantID),
    }
}
</code></pre></p><p><strong>Time Ranges</strong>:
<li><strong>1 Minute</strong>: Real-time monitoring</li>
<li><strong>5 Minutes</strong>: Short-term trends</li>
<li><strong>1 Hour</strong>: Medium-term analysis</li>
<li><strong>24 Hours</strong>: Daily patterns</li>
<li><strong>7 Days</strong>: Weekly trends</li>
<li><strong>30 Days</strong>: Monthly analysis</li></p><p><strong>Aggregation Functions</strong>:
<li><strong>Rate Calculation</strong>: Requests per second, samples per second</li>
<li><strong>Percentage Calculation</strong>: Allow rate, deny rate, utilization</li>
<li><strong>Statistical Functions</strong>: Min, max, average, percentiles</li>
<li><strong>Trend Analysis</strong>: Rate of change, acceleration</li></p><p>#### Caching Strategy</p><p><strong>Description</strong>: Multi-level caching system that optimizes performance while maintaining data accuracy.</p><p><strong>Implementation</strong>:
<pre><code>// Cache Levels
type CacheLevel int</p><p>const (
    Level1Cache CacheLevel = iota // In-memory cache
    Level2Cache                   // Redis cache
    Level3Cache                   // Database cache
)</p><p>type CacheManager struct {
    level1 *MemoryCache
    level2 *RedisCache
    level3 *DatabaseCache
}</p><p>func (cm *CacheManager) Get(key string) (interface{}, bool) {
    // Try Level 1 (fastest)
    if value, found := cm.level1.Get(key); found {
        return value, true
    }
    
    // Try Level 2
    if value, found := cm.level2.Get(key); found {
        cm.level1.Set(key, value) // Populate Level 1
        return value, true
    }
    
    // Try Level 3
    if value, found := cm.level3.Get(key); found {
        cm.level2.Set(key, value) // Populate Level 2
        cm.level1.Set(key, value) // Populate Level 1
        return value, true
    }
    
    return nil, false
}
</code></pre></p><p><strong>Cache Characteristics</strong>:
<li><strong>Level 1</strong>: In-memory, <1ms access, 100MB size</li>
<li><strong>Level 2</strong>: Redis, <5ms access, 1GB size</li>
<li><strong>Level 3</strong>: Database, <50ms access, unlimited size</li></p><p><h3>3. External Authorization (Ext Authz)</h3></p><p>#### gRPC Ext Authz Integration</p><p><strong>Description</strong>: Integration with Envoy's external authorization filter for real-time authorization decisions.</p><p><strong>Implementation</strong>:
<pre><code>// Ext Authz Service Definition
service Authorization {
    rpc Check(CheckRequest) returns (CheckResponse);
}</p><p>message CheckRequest {
    repeated Attribute attributes = 1;
}</p><p>message CheckResponse {
    Status status = 1;
    repeated HeaderValueOption headers_to_add = 2;
    repeated HeaderValueOption headers_to_set = 3;
    repeated HeaderValueOption headers_to_remove = 4;
}
</code></pre></p><p><strong>Go Implementation</strong>:
<pre><code>// Ext Authz Handler
func (s <em>ExtAuthzServer) Check(ctx context.Context, req </em>authz.CheckRequest) (*authz.CheckResponse, error) {
    // Extract tenant ID from request
    tenantID := extractTenantID(req)
    
    // Get tenant information
    tenant := s.rls.GetOrCreateTenant(tenantID)
    
    // Check rate limits
    allowed, err := s.rls.CheckRateLimits(tenant, req)
    if err != nil {
        return &authz.CheckResponse{
            Status: &rpc.Status{
                Code: int32(codes.Internal),
                Message: err.Error(),
            },
        }, nil
    }
    
    if allowed {
        return &authz.CheckResponse{
            Status: &rpc.Status{Code: int32(codes.OK)},
            HeadersToAdd: []*core.HeaderValueOption{
                {Header: &core.HeaderValue{Key: "X-Rate-Limited", Value: "false"}},
            },
        }, nil
    }
    
    return &authz.CheckResponse{
        Status: &rpc.Status{
            Code: int32(codes.PermissionDenied),
            Message: "Rate limit exceeded",
        },
        HeadersToAdd: []*core.HeaderValueOption{
            {Header: &core.HeaderValue{Key: "X-Rate-Limited", Value: "true"}},
        },
    }, nil
}
</code></pre></p><p><strong>Features</strong>:
<li><strong>Real-time Decisions</strong>: Sub-10ms authorization decisions</li>
<li><strong>Header Injection</strong>: Add custom headers to requests</li>
<li><strong>Status Codes</strong>: Proper HTTP status codes for different scenarios</li>
<li><strong>Error Handling</strong>: Comprehensive error handling and logging</li></p><p><h3>4. Dynamic Configuration Management</h3></p><p>#### Runtime Configuration Updates</p><p><strong>Description</strong>: Ability to update rate limiting configurations without service restarts.</p><p><strong>Implementation</strong>:
<pre><code>// Configuration Manager
type ConfigManager struct {
    config     *Config
    watchers   []ConfigWatcher
    mutex      sync.RWMutex
}</p><p>type Config struct {
    GlobalLimits    GlobalLimits    <code>yaml:"global_limits"</code>
    TenantLimits    map[string]TenantLimits <code>yaml:"tenant_limits"</code>
    EnforcementMode string          <code>yaml:"enforcement_mode"</code>
    Logging         LoggingConfig   <code>yaml:"logging"</code>
}</p><p>// Configuration Update Handler
func (cm <em>ConfigManager) UpdateConfig(newConfig </em>Config) error {
    cm.mutex.Lock()
    defer cm.mutex.Unlock()
    
    // Validate new configuration
    if err := cm.validateConfig(newConfig); err != nil {
        return err
    }
    
    // Apply configuration changes
    cm.applyConfigChanges(cm.config, newConfig)
    
    // Update current configuration
    cm.config = newConfig
    
    // Notify watchers
    cm.notifyWatchers(newConfig)
    
    return nil
}
</code></pre></p><p><strong>Configuration Sources</strong>:
<li><strong>Kubernetes ConfigMaps</strong>: Primary configuration source</li>
<li><strong>Environment Variables</strong>: Runtime overrides</li>
<li><strong>API Endpoints</strong>: Dynamic updates via REST API</li>
<li><strong>File System</strong>: Local configuration files</li></p><p><strong>Update Mechanisms</strong>:
<li><strong>Hot Reload</strong>: Configuration changes applied immediately</li>
<li><strong>Validation</strong>: Comprehensive validation before application</li>
<li><strong>Rollback</strong>: Automatic rollback on validation failures</li>
<li><strong>Audit Trail</strong>: Complete audit trail of configuration changes</li></p><p><h3>5. Comprehensive Monitoring and Metrics</h3></p><p>#### Prometheus Metrics</p><p><strong>Description</strong>: Extensive Prometheus metrics for monitoring system health, performance, and rate limiting decisions.</p><p><strong>Implementation</strong>:
<pre><code>// Metrics Collection
type MetricsCollector struct {
    requestCounter    *prometheus.CounterVec
    requestDuration   *prometheus.HistogramVec
    rateLimitCounter  *prometheus.CounterVec
    tenantMetrics     *prometheus.GaugeVec
    systemMetrics     *prometheus.GaugeVec
}</p><p>// Metric Definitions
var (
    requestCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "mimir_edge_requests_total",
            Help: "Total number of requests processed",
        },
        []string{"tenant_id", "route_decision", "status"},
    )
    
    requestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "mimir_edge_request_duration_seconds",
            Help:    "Request duration in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"tenant_id", "route_decision"},
    )
    
    rateLimitCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "mimir_edge_rate_limits_total",
            Help: "Total number of rate limiting decisions",
        },
        []string{"tenant_id", "decision", "limit_type"},
    )
)
</code></pre></p><p><strong>Metric Categories</strong>:
<li><strong>Request Metrics</strong>: Total requests, duration, status codes</li>
<li><strong>Rate Limiting Metrics</strong>: Allow/deny decisions, limit types</li>
<li><strong>Tenant Metrics</strong>: Per-tenant usage and limits</li>
<li><strong>System Metrics</strong>: Resource utilization, health status</li>
<li><strong>Business Metrics</strong>: Cost tracking, SLA compliance</li></p><p>#### Health Checks</p><p><strong>Description</strong>: Comprehensive health checking system for all components.</p><p><strong>Implementation</strong>:
<pre><code>// Health Check Structure
type HealthCheck struct {
    Name     string                 <code>json:"name"</code>
    Status   string                 <code>json:"status"</code>
    Details  map[string]interface{} <code>json:"details,omitempty"</code>
    Timestamp time.Time             <code>json:"timestamp"</code>
}</p><p>type HealthChecker struct {
    checks map[string]HealthCheckFunc
}</p><p>// Health Check Functions
func (hc *HealthChecker) AddCheck(name string, check HealthCheckFunc) {
    hc.checks[name] = check
}</p><p>func (hc *HealthChecker) RunChecks() map[string]HealthCheck {
    results := make(map[string]HealthCheck)
    
    for name, check := range hc.checks {
        status, details := check()
        results[name] = HealthCheck{
            Name:      name,
            Status:    status,
            Details:   details,
            Timestamp: time.Now(),
        }
    }
    
    return results
}
</code></pre></p><p><strong>Health Check Types</strong>:
<li><strong>Liveness</strong>: Service is running and responsive</li>
<li><strong>Readiness</strong>: Service is ready to handle requests</li>
<li><strong>Dependencies</strong>: External dependencies are available</li>
<li><strong>Performance</strong>: Service is performing within acceptable limits</li></p><p><h3>6. Admin UI and Management</h3></p><p>#### Real-time Dashboard</p><p><strong>Description</strong>: Comprehensive web-based interface for monitoring and managing the system.</p><p><strong>Features</strong>:
<li><strong>Real-time Metrics</strong>: Live updates of system metrics</li>
<li><strong>Interactive Charts</strong>: Rich, interactive visualizations</li>
<li><strong>Tenant Management</strong>: Per-tenant monitoring and configuration</li>
<li><strong>System Health</strong>: Comprehensive health status monitoring</li>
<li><strong>Configuration Management</strong>: Runtime configuration updates</li></p><p><strong>Implementation</strong>:
<pre><code>// Dashboard Component
interface DashboardProps {
  apiClient: APIClient;
  refreshInterval: number;
}</p><p>const Dashboard: React.FC<DashboardProps> = ({ apiClient, refreshInterval }) => {
  const [metrics, setMetrics] = useState<SystemMetrics | null>(null);
  const [tenants, setTenants] = useState<Tenant[]>([]);
  const [health, setHealth] = useState<HealthStatus | null>(null);
  
  // Real-time updates
  useEffect(() => {
    const interval = setInterval(async () => {
      const [metricsData, tenantsData, healthData] = await Promise.all([
        apiClient.getMetrics(),
        apiClient.getTenants(),
        apiClient.getHealth(),
      ]);
      
      setMetrics(metricsData);
      setTenants(tenantsData);
      setHealth(healthData);
    }, refreshInterval);
    
    return () => clearInterval(interval);
  }, [apiClient, refreshInterval]);
  
  return (
    <div className="dashboard">
      <MetricsOverview metrics={metrics} />
      <TenantsTable tenants={tenants} />
      <HealthStatus health={health} />
    </div>
  );
};
</code></pre></p><p><strong>Dashboard Sections</strong>:
<li><strong>Overview</strong>: System-wide metrics and status</li>
<li><strong>Tenants</strong>: Per-tenant metrics and configuration</li>
<li><strong>System Health</strong>: Component health and performance</li>
<li><strong>Configuration</strong>: Runtime configuration management</li>
<li><strong>Wiki</strong>: Documentation and troubleshooting guides</li></p><p><h3>7. Advanced Security Features</h3></p><p>#### Authentication and Authorization</p><p><strong>Description</strong>: Comprehensive security features including authentication, authorization, and audit logging.</p><p><strong>Implementation</strong>:
<pre><code>// Authentication Middleware
type AuthMiddleware struct {
    authenticator Authenticator
    authorizer    Authorizer
}</p><p>func (am <em>AuthMiddleware) Authenticate(r </em>http.Request) (*User, error) {
    // Extract credentials
    token := extractToken(r)
    
    // Validate token
    user, err := am.authenticator.ValidateToken(token)
    if err != nil {
        return nil, err
    }
    
    return user, nil
}</p><p>func (am <em>AuthMiddleware) Authorize(user </em>User, resource string, action string) bool {
    return am.authorizer.CheckPermission(user, resource, action)
}
</code></pre></p><p><strong>Security Features</strong>:
<li><strong>Token-based Authentication</strong>: JWT token validation</li>
<li><strong>Role-based Access Control</strong>: Granular permission management</li>
<li><strong>Audit Logging</strong>: Complete audit trail of all actions</li>
<li><strong>Data Encryption</strong>: Encryption in transit and at rest</li>
<li><strong>Rate Limiting</strong>: Protection against abuse</li></p><p><h3>8. Performance Optimization</h3></p><p>#### High-Performance Architecture</p><p><strong>Description</strong>: Optimized architecture for high throughput and low latency.</p><p><strong>Optimization Techniques</strong>:
<li><strong>Connection Pooling</strong>: Efficient connection management</li>
<li><strong>Async Processing</strong>: Non-blocking I/O operations</li>
<li><strong>Memory Optimization</strong>: Efficient memory usage patterns</li>
<li><strong>Caching</strong>: Multi-level caching strategies</li>
<li><strong>Load Balancing</strong>: Intelligent load distribution</li></p><p><strong>Performance Targets</strong>:
<li><strong>Latency</strong>: <10ms for rate limiting decisions</li>
<li><strong>Throughput</strong>: 100,000+ requests per second</li>
<li><strong>Memory</strong>: <2GB per instance</li>
<li><strong>CPU</strong>: <20% utilization under normal load</li></p><p><h2>Feature Benefits</h2></p><p><h3>1. Cost Control</h3>
<li><strong>50-70% Cost Reduction</strong>: Significant infrastructure cost savings</li>
<li><strong>Resource Optimization</strong>: Efficient resource utilization</li>
<li><strong>Predictable Costs</strong>: Transparent cost attribution and billing</li>
<li><strong>Budget Management</strong>: Proactive budget control mechanisms</li></p><p><h3>2. Service Protection</h3>
<li><strong>DDoS Protection</strong>: Protection against distributed attacks</li>
<li><strong>Resource Isolation</strong>: Tenant isolation prevents resource exhaustion</li>
<li><strong>Circuit Breaking</strong>: Automatic failure protection</li>
<li><strong>Graceful Degradation</strong>: Maintain service during high load</li></p><p><h3>3. Operational Excellence</h3>
<li><strong>Automated Operations</strong>: Reduced manual intervention</li>
<li><strong>Real-time Monitoring</strong>: Comprehensive visibility into system health</li>
<li><strong>Proactive Alerting</strong>: Early warning of potential issues</li>
<li><strong>Self-healing</strong>: Automatic recovery from failures</li></p><p><h3>4. Compliance and Governance</h3>
<li><strong>Audit Trail</strong>: Complete audit logging for compliance</li>
<li><strong>Policy Enforcement</strong>: Automated policy enforcement</li>
<li><strong>Data Protection</strong>: Comprehensive data security measures</li>
<li><strong>Regulatory Compliance</strong>: Built-in compliance features</li></p><p><h2>Conclusion</h2></p><p>The Mimir Edge Enforcement system provides a comprehensive set of core features that address the critical challenges of modern observability environments:</p><p><li><strong>Advanced Rate Limiting</strong>: Sophisticated rate limiting with selective enforcement</li>
<li><strong>Intelligent Aggregation</strong>: Time-based aggregation with intelligent caching</li>
<li><strong>Real-time Authorization</strong>: Fast, reliable authorization decisions</li>
<li><strong>Dynamic Configuration</strong>: Runtime configuration updates without downtime</li>
<li><strong>Comprehensive Monitoring</strong>: Extensive metrics and health monitoring</li>
<li><strong>Rich Management Interface</strong>: Powerful admin UI for system management</li>
<li><strong>Enterprise Security</strong>: Comprehensive security and compliance features</li>
<li><strong>High Performance</strong>: Optimized for high throughput and low latency</li></p><p>These features work together to provide a robust, scalable, and cost-effective solution for managing observability infrastructure.</p><p>---</p><p><strong>Next Steps</strong>:
<li>Explore advanced features in <code>features/advanced-features.md</code></li>
<li>Review selective traffic routing in <code>features/selective-traffic-routing.md</code></li>
<li>Understand time-based aggregation in <code>features/time-based-aggregation.md</code></li>
<li>Learn about deployment strategies in <code>deployment/deployment-strategy.md</code></li></p><p><strong>Related Documents</strong>:
<li>[Advanced Features](advanced-features.md)</li>
<li>[Selective Traffic Routing](selective-traffic-routing.md)</li>
<li>[Time-based Aggregation](time-based-aggregation.md)</li>
<li>[Rate Limit Service](../components/rate-limit-service.md)</li></p><p>---</p><p>
<h2>Deployment Strategy</h2></p><p>
<h2>Overview</h2></p><p>The Mimir Edge Enforcement system is designed for zero-risk deployment with comprehensive rollback capabilities. The deployment strategy follows a phased approach that ensures minimal impact on existing services while providing full validation and monitoring capabilities.</p><p><h2>Deployment Phases</h2></p><p><h3>Phase 1: Mirror Mode (Zero Impact)</h3></p><p>#### Objective
Deploy the system in shadow mode to validate functionality and collect baseline metrics without any impact on production traffic.</p><p>#### Architecture
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                              Phase 1: Mirror Mode                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ   Alloy     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   NGINX     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Mimir     ‚îÇ    ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  (Client)   ‚îÇ    ‚îÇ  (Proxy)    ‚îÇ    ‚îÇDistributor  ‚îÇ    ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                           ‚îÇ                                ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                           ‚ñº                                ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                        ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                    ‚îÇ   Mirror    ‚îÇ                        ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                    ‚îÇ   Traffic   ‚îÇ                        ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                        ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                           ‚îÇ                                ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                           ‚ñº                                ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                    ‚îÇ   Envoy     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   RLS       ‚îÇ    ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                    ‚îÇ (Shadow)    ‚îÇ    ‚îÇ(Shadow)     ‚îÇ    ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ             ‚îÇ     ‚îÇ
‚îÇ                                                           ‚îÇ             ‚îÇ     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></p><p>#### NGINX Configuration
<pre><code><h1>nginx-mirror.conf</h1>
upstream mimir_direct {
    server distributor.mimir.svc.cluster.local:8080;
}</p><p>upstream mimirrls {
    server mimirrls.mimir-edge-enforcement.svc.cluster.local:8080;
}</p><p>server {
    listen 80;
    
    # Main traffic - direct to Mimir
    location /api/v1/push {
        proxy_pass http://mimir_direct;
        
        # Mirror traffic to Envoy (shadow mode)
        mirror /mirror;
        mirror_request_body on;
    }
    
    # Mirror endpoint - traffic goes to Envoy but response is ignored
    location = /mirror {
        internal;
        proxy_pass http://mimirrls;
        proxy_pass_request_body on;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri;
        
        # Ignore response from mirror
        proxy_ignore_client_abort on;
        proxy_ignore_headers X-Accel-*;
    }
}
</code></pre></p><p>#### Deployment Steps
<pre><code><h1>1. Deploy RLS service</h1>
helm install mimir-rls charts/mimir-rls/ \
  --namespace mimir-edge-enforcement \
  --set rls.replicas=3 \
  --set rls.config.failureModeAllow=true</p><p><h1>2. Deploy Envoy proxy</h1>
helm install mimir-envoy charts/envoy/ \
  --namespace mimir-edge-enforcement \
  --set envoy.replicas=3</p><p><h1>3. Deploy overrides-sync controller</h1>
helm install overrides-sync charts/overrides-sync/ \
  --namespace mimir-edge-enforcement</p><p><h1>4. Apply NGINX mirror configuration</h1>
kubectl apply -f examples/nginx-mirror.yaml</p><p><h1>5. Verify deployment</h1>
kubectl get pods -n mimir-edge-enforcement
kubectl logs -f deployment/mimir-rls -n mimir-edge-enforcement
</code></pre></p><p>#### Validation Criteria
<li>[ ] All pods are running and healthy</li>
<li>[ ] RLS service is receiving mirrored traffic</li>
<li>[ ] No impact on existing Mimir traffic</li>
<li>[ ] Metrics are being collected</li>
<li>[ ] Admin UI is accessible and showing data</li></p><p>#### Success Metrics
<li><strong>Zero Impact</strong>: 100% of requests reach Mimir distributor</li>
<li><strong>Shadow Traffic</strong>: RLS receives mirrored requests</li>
<li><strong>System Health</strong>: All components healthy</li>
<li><strong>Metrics Collection</strong>: Prometheus metrics populated</li></p><p><h3>Phase 2: Canary Mode (Gradual Rollout)</h3></p><p>#### Objective
Gradually shift traffic from direct Mimir access to Envoy enforcement, starting with a small percentage and monitoring closely.</p><p>#### Architecture
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                              Phase 2: Canary Mode                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ   Alloy     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   NGINX     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Envoy     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Mimir     ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  (Client)   ‚îÇ    ‚îÇ  (Proxy)    ‚îÇ    ‚îÇ (Canary)    ‚îÇ    ‚îÇDistributor  ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                           ‚îÇ                   ‚îÇ                                ‚îÇ
‚îÇ                           ‚ñº                   ‚ñº                                ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ                    ‚îÇ   RLS       ‚îÇ    ‚îÇ   RLS       ‚îÇ                         ‚îÇ
‚îÇ                    ‚îÇ(Canary)     ‚îÇ    ‚îÇ(Canary)     ‚îÇ                         ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îÇ
‚îÇ                                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></p><p>#### NGINX Configuration (10% Canary)
<pre><code><h1>nginx-canary-10.conf</h1>
upstream mimir_direct {
    server distributor.mimir.svc.cluster.local:8080;
}</p><p>upstream mimirrls {
    server mimirrls.mimir-edge-enforcement.svc.cluster.local:8080;
}</p><p><h1>Split traffic based on request ID hash</h1>
split_clients "${request_id}" $backend {
    10%     mimirrls;
    *       mimir_direct;
}</p><p>server {
    listen 80;
    
    location /api/v1/push {
        proxy_pass http://$backend;
        
        # Add headers for tracking
        add_header X-Edge-Enforcement $backend;
        add_header X-Canary-Percentage "10%";
    }
}
</code></pre></p><p>#### Deployment Steps
<pre><code><h1>1. Scale up RLS service for canary traffic</h1>
helm upgrade mimir-rls charts/mimir-rls/ \
  --namespace mimir-edge-enforcement \
  --set rls.replicas=5 \
  --set rls.config.failureModeAllow=false</p><p><h1>2. Scale up Envoy proxy</h1>
helm upgrade mimir-envoy charts/envoy/ \
  --namespace mimir-edge-enforcement \
  --set envoy.replicas=5</p><p><h1>3. Apply canary NGINX configuration</h1>
kubectl apply -f examples/nginx-canary-10.yaml</p><p><h1>4. Monitor canary traffic</h1>
kubectl logs -f deployment/mimir-rls -n mimir-edge-enforcement | grep "canary"
</code></pre></p><p>#### Canary Progression
<pre><code><h1>10% canary</h1>
kubectl apply -f examples/nginx-canary-10.yaml</p><p><h1>25% canary</h1>
kubectl apply -f examples/nginx-canary-25.yaml</p><p><h1>50% canary</h1>
kubectl apply -f examples/nginx-canary-50.yaml</p><p><h1>75% canary</h1>
kubectl apply -f examples/nginx-canary-75.yaml</p><p><h1>100% canary</h1>
kubectl apply -f examples/nginx-canary-100.yaml
</code></pre></p><p>#### Validation Criteria
<li>[ ] Canary traffic is being routed correctly</li>
<li>[ ] Error rates are within acceptable limits</li>
<li>[ ] Latency impact is minimal</li>
<li>[ ] All tenants are being enforced</li>
<li>[ ] Rollback capability is tested</li></p><p>#### Success Metrics
<li><strong>Error Rate</strong>: <0.1% error rate for canary traffic</li>
<li><strong>Latency Impact</strong>: <10ms additional latency</li>
<li><strong>Throughput</strong>: No degradation in request processing</li>
<li><strong>Enforcement</strong>: All tenant limits being enforced correctly</li></p><p><h3>Phase 3: Full Mode (Complete Deployment)</h3></p><p>#### Objective
Deploy the system in full enforcement mode with all traffic going through Envoy and RLS.</p><p>#### Architecture
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                              Phase 3: Full Mode                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ   Alloy     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   NGINX     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Envoy     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Mimir     ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  (Client)   ‚îÇ    ‚îÇ  (Proxy)    ‚îÇ    ‚îÇ (Full)      ‚îÇ    ‚îÇDistributor  ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                           ‚îÇ                   ‚îÇ                                ‚îÇ
‚îÇ                           ‚ñº                   ‚ñº                                ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ                    ‚îÇ   RLS       ‚îÇ    ‚îÇ   RLS       ‚îÇ                         ‚îÇ
‚îÇ                    ‚îÇ(Full)       ‚îÇ    ‚îÇ(Full)       ‚îÇ                         ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îÇ
‚îÇ                                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></p><p>#### NGINX Configuration (Full Mode)
<pre><code><h1>nginx-full.conf</h1>
upstream mimirrls {
    server mimirrls.mimir-edge-enforcement.svc.cluster.local:8080;
}</p><p>server {
    listen 80;
    
    location /api/v1/push {
        proxy_pass http://mimirrls;
        
        # Add headers for tracking
        add_header X-Edge-Enforcement "full";
        add_header X-Deployment-Mode "production";
    }
}
</code></pre></p><p>#### Deployment Steps
<pre><code><h1>1. Scale to production capacity</h1>
helm upgrade mimir-rls charts/mimir-rls/ \
  --namespace mimir-edge-enforcement \
  --set rls.replicas=10 \
  --set rls.config.failureModeAllow=false \
  --set rls.resources.requests.memory=8Gi \
  --set rls.resources.requests.cpu=1000m</p><p><h1>2. Scale Envoy to production capacity</h1>
helm upgrade mimir-envoy charts/envoy/ \
  --namespace mimir-edge-enforcement \
  --set envoy.replicas=10 \
  --set envoy.resources.requests.memory=4Gi \
  --set envoy.resources.requests.cpu=500m</p><p><h1>3. Apply full NGINX configuration</h1>
kubectl apply -f examples/nginx-full.yaml</p><p><h1>4. Enable HPA for auto-scaling</h1>
kubectl apply -f examples/hpa-rls.yaml
kubectl apply -f examples/hpa-envoy.yaml
</code></pre></p><p>#### Validation Criteria
<li>[ ] All traffic is going through Envoy</li>
<li>[ ] All tenant limits are being enforced</li>
<li>[ ] System performance is stable</li>
<li>[ ] Monitoring and alerting are working</li>
<li>[ ] Rollback procedures are documented and tested</li></p><p>#### Success Metrics
<li><strong>Full Enforcement</strong>: 100% of traffic through Envoy</li>
<li><strong>System Stability</strong>: 99.9% uptime</li>
<li><strong>Performance</strong>: <10ms latency impact</li>
<li><strong>Compliance</strong>: All tenant limits enforced</li></p><p><h2>Rollback Procedures</h2></p><p><h3>Emergency Rollback (5 Minutes)</h3></p><p>#### Quick Rollback
<pre><code><h1>1. Revert NGINX configuration to direct Mimir access</h1>
kubectl apply -f examples/nginx-direct.yaml</p><p><h1>2. Verify traffic is flowing directly to Mimir</h1>
kubectl logs -f deployment/nginx-ingress -n ingress-nginx</p><p><h1>3. Scale down enforcement components</h1>
kubectl scale deployment mimir-rls --replicas=0 -n mimir-edge-enforcement
kubectl scale deployment mimir-envoy --replicas=0 -n mimir-edge-enforcement
</code></pre></p><p>#### NGINX Direct Configuration
<pre><code><h1>nginx-direct.yaml</h1>
upstream mimir_direct {
    server distributor.mimir.svc.cluster.local:8080;
}</p><p>server {
    listen 80;
    
    location /api/v1/push {
        proxy_pass http://mimir_direct;
        
        # Add header indicating direct access
        add_header X-Edge-Enforcement "disabled";
        add_header X-Rollback "emergency";
    }
}
</code></pre></p><p><h3>Graceful Rollback (30 Minutes)</h3></p><p>#### Step-by-Step Rollback
<pre><code><h1>1. Reduce canary percentage gradually</h1>
kubectl apply -f examples/nginx-canary-50.yaml
sleep 300  # Wait 5 minutes</p><p>kubectl apply -f examples/nginx-canary-25.yaml
sleep 300  # Wait 5 minutes</p><p>kubectl apply -f examples/nginx-canary-10.yaml
sleep 300  # Wait 5 minutes</p><p><h1>2. Switch to mirror mode</h1>
kubectl apply -f examples/nginx-mirror.yaml</p><p><h1>3. Scale down enforcement components</h1>
kubectl scale deployment mimir-rls --replicas=3 -n mimir-edge-enforcement
kubectl scale deployment mimir-envoy --replicas=3 -n mimir-edge-enforcement</p><p><h1>4. Disable enforcement</h1>
kubectl patch deployment mimir-rls -p '{"spec":{"template":{"spec":{"containers":[{"name":"rls","env":[{"name":"ENFORCEMENT_DISABLED","value":"true"}]}]}}}}'
</code></pre></p><p><h2>Monitoring and Validation</h2></p><p><h3>Pre-Deployment Checks</h3></p><p>#### Infrastructure Validation
<pre><code><h1>Check cluster resources</h1>
kubectl get nodes -o custom-columns="NAME:.metadata.name,CPU:.status.capacity.cpu,MEMORY:.status.capacity.memory"</p><p><h1>Check namespace resources</h1>
kubectl get pods -n mimir-edge-enforcement -o wide</p><p><h1>Check network connectivity</h1>
kubectl run test-pod --image=busybox --rm -it --restart=Never -- nslookup mimirrls.mimir-edge-enforcement.svc.cluster.local
</code></pre></p><p>#### Configuration Validation
<pre><code><h1>Validate Helm charts</h1>
helm lint charts/mimir-rls/
helm lint charts/envoy/
helm lint charts/overrides-sync/</p><p><h1>Dry run deployment</h1>
helm install mimir-rls charts/mimir-rls/ --dry-run --debug</p><p><h1>Validate ConfigMaps</h1>
kubectl get configmap mimir-overrides -n mimir -o yaml
</code></pre></p><p><h3>Post-Deployment Validation</h3></p><p>#### Health Checks
<pre><code><h1>Check pod health</h1>
kubectl get pods -n mimir-edge-enforcement</p><p><h1>Check service health</h1>
kubectl get svc -n mimir-edge-enforcement</p><p><h1>Check endpoints</h1>
kubectl get endpoints -n mimir-edge-enforcement</p><p><h1>Check logs</h1>
kubectl logs -f deployment/mimir-rls -n mimir-edge-enforcement
kubectl logs -f deployment/mimir-envoy -n mimir-edge-enforcement
</code></pre></p><p>#### Performance Validation
<pre><code><h1>Check resource usage</h1>
kubectl top pods -n mimir-edge-enforcement</p><p><h1>Check metrics</h1>
curl http://localhost:9090/metrics | grep rls_</p><p><h1>Check API endpoints</h1>
curl http://localhost:8082/api/health
curl http://localhost:8082/api/overview
</code></pre></p><p>#### Traffic Validation
<pre><code><h1>Check NGINX logs</h1>
kubectl logs -f deployment/nginx-ingress -n ingress-nginx | grep "api/v1/push"</p><p><h1>Check Envoy logs</h1>
kubectl logs -f deployment/mimir-envoy -n mimir-edge-enforcement</p><p><h1>Check RLS logs</h1>
kubectl logs -f deployment/mimir-rls -n mimir-edge-enforcement | grep "decision"
</code></pre></p><p><h2>Configuration Management</h2></p><p><h3>Environment-Specific Configurations</h3></p><p>#### Development Environment
<pre><code><h1>values-dev.yaml</h1>
global:
  environment: development</p><p>rls:
  replicas: 1
  config:
    maxRequestBytes: 10485760  # 10MB
    failureModeAllow: true
  resources:
    requests:
      memory: 1Gi
      cpu: 100m
    limits:
      memory: 2Gi
      cpu: 200m</p><p>envoy:
  replicas: 1
  resources:
    requests:
      memory: 512Mi
      cpu: 50m
    limits:
      memory: 1Gi
      cpu: 100m
</code></pre></p><p>#### Staging Environment
<pre><code><h1>values-staging.yaml</h1>
global:
  environment: staging</p><p>rls:
  replicas: 3
  config:
    maxRequestBytes: 52428800  # 50MB
    failureModeAllow: false
  resources:
    requests:
      memory: 4Gi
      cpu: 500m
    limits:
      memory: 8Gi
      cpu: 1000m</p><p>envoy:
  replicas: 3
  resources:
    requests:
      memory: 2Gi
      cpu: 250m
    limits:
      memory: 4Gi
      cpu: 500m
</code></pre></p><p>#### Production Environment
<pre><code><h1>values-production.yaml</h1>
global:
  environment: production</p><p>rls:
  replicas: 10
  config:
    maxRequestBytes: 52428800  # 50MB
    failureModeAllow: false
  resources:
    requests:
      memory: 8Gi
      cpu: 1000m
    limits:
      memory: 16Gi
      cpu: 4000m</p><p>envoy:
  replicas: 10
  resources:
    requests:
      memory: 4Gi
      cpu: 500m
    limits:
      memory: 8Gi
      cpu: 2000m
</code></pre></p><p><h3>Deployment Commands</h3></p><p>#### Development Deployment
<pre><code><h1>Deploy to development</h1>
helm install mimir-edge-enforcement charts/ \
  --namespace mimir-edge-enforcement \
  -f values-dev.yaml \
  --set global.environment=development
</code></pre></p><p>#### Staging Deployment
<pre><code><h1>Deploy to staging</h1>
helm install mimir-edge-enforcement charts/ \
  --namespace mimir-edge-enforcement \
  -f values-staging.yaml \
  --set global.environment=staging
</code></pre></p><p>#### Production Deployment
<pre><code><h1>Deploy to production</h1>
helm install mimir-edge-enforcement charts/ \
  --namespace mimir-edge-enforcement \
  -f values-production.yaml \
  --set global.environment=production
</code></pre></p><p><h2>Risk Mitigation</h2></p><p><h3>Technical Risks</h3></p><p>#### Service Failure
<li><strong>Risk</strong>: RLS or Envoy service failure</li>
<li><strong>Mitigation</strong>: Configurable failure modes (allow/deny)</li>
<li><strong>Monitoring</strong>: Health checks and alerting</li>
<li><strong>Recovery</strong>: Automatic restart via Kubernetes</li></p><p>#### Performance Impact
<li><strong>Risk</strong>: High latency or throughput degradation</li>
<li><strong>Mitigation</strong>: Comprehensive load testing</li>
<li><strong>Monitoring</strong>: Real-time performance metrics</li>
<li><strong>Recovery</strong>: Auto-scaling and rollback procedures</li></p><p>#### Configuration Errors
<li><strong>Risk</strong>: Incorrect tenant limits or enforcement rules</li>
<li><strong>Mitigation</strong>: Configuration validation</li>
<li><strong>Monitoring</strong>: Configuration drift detection</li>
<li><strong>Recovery</strong>: ConfigMap sync and validation</li></p><p><h3>Operational Risks</h3></p><p>#### Deployment Issues
<li><strong>Risk</strong>: Failed deployment or configuration</li>
<li><strong>Mitigation</strong>: Gradual rollout with rollback capability</li>
<li><strong>Monitoring</strong>: Deployment status and health checks</li>
<li><strong>Recovery</strong>: Instant rollback procedures</li></p><p>#### Monitoring Gaps
<li><strong>Risk</strong>: Insufficient monitoring or alerting</li>
<li><strong>Mitigation</strong>: Comprehensive observability</li>
<li><strong>Monitoring</strong>: Multi-level monitoring and alerting</li>
<li><strong>Recovery</strong>: Manual intervention procedures</li></p><p>#### Security Concerns
<li><strong>Risk</strong>: Security vulnerabilities or data exposure</li>
<li><strong>Mitigation</strong>: Security hardening and RBAC</li>
<li><strong>Monitoring</strong>: Security scanning and audit logs</li>
<li><strong>Recovery</strong>: Security incident response procedures</li></p><p><h2>Success Criteria</h2></p><p><h3>Phase 1 Success Criteria</h3>
<li>[ ] Zero impact on existing Mimir traffic</li>
<li>[ ] RLS service receiving and processing mirrored traffic</li>
<li>[ ] All metrics and monitoring working correctly</li>
<li>[ ] Admin UI accessible and functional</li></p><p><h3>Phase 2 Success Criteria</h3>
<li>[ ] Canary traffic being processed correctly</li>
<li>[ ] Error rates within acceptable limits (<0.1%)</li>
<li>[ ] Latency impact minimal (<10ms)</li>
<li>[ ] Rollback procedures tested and working</li></p><p><h3>Phase 3 Success Criteria</h3>
<li>[ ] All traffic going through enforcement</li>
<li>[ ] System performance stable and acceptable</li>
<li>[ ] All tenant limits being enforced correctly</li>
<li>[ ] Monitoring and alerting fully operational</li></p><p><h2>Conclusion</h2></p><p>The deployment strategy provides a comprehensive, risk-mitigated approach to deploying the Mimir Edge Enforcement system. The phased approach ensures minimal impact on existing services while providing full validation and monitoring capabilities.</p><p>The rollback procedures ensure that any issues can be quickly addressed, while the monitoring and validation procedures provide confidence in the deployment process. The configuration management approach supports multiple environments and ensures consistent deployments across development, staging, and production.</p><p>---</p><p><strong>Next Steps</strong>: Review component-specific deployment guides and monitoring setup procedures.</p><p>---</p><p>
<h2>Conclusion</h2></p><p>This comprehensive documentation provides a complete overview of the Mimir Edge Enforcement system, covering all aspects from architecture and design to deployment and operations. The documentation is designed to serve multiple stakeholders including leadership, architects, developers, and operations engineers.</p><p>For questions or contributions, please contact the development team or submit a pull request to update this documentation.</p><p>---</p><p><strong>Document Version</strong>: 1.0  
<strong>Last Updated</strong>: January 2024  
<strong>Maintainer</strong>: Development Team  
<strong>License</strong>: Apache-2.0</p><p>
</body>
</html>