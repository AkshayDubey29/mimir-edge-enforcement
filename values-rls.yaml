# RLS (Rate Limit Service) Values - Production Configuration
# Use this file for deploying RLS in production with optimized settings

# Service configuration
service:
  type: ClusterIP
  port: 8082  # Main service port (admin API)
  ports:
    extAuthz: 8080
    rateLimit: 8081
    admin: 8082
    metrics: 9090

# Tenant identification
tenantHeader: "X-Scope-OrgID"

# Limits configuration - Production
# SELECTIVE ENFORCEMENT: Only enforce cardinality limits (per_metric_series_limit and per_user_series_limit)
limits:
  maxRequestBytes: "10485760"  # 10 MiB - Increased for large Alloy payloads
  maxBodyBytes: 0              # 0 = Disabled - No body size enforcement
  failureModeAllow: true       # Production: Allow requests when parsing fails (with intelligent fallback)
  defaultSamplesPerSecond: 1000      # 1000 samples/sec - Enable rate limiting
  defaultBurstPercent: 10      # 10% burst allowance
  enforceBodyParsing: true     # Production: Enable body parsing for cardinality analysis
  defaultMaxLabelsPerSeries: 60      # per_user_series_limit - ENFORCED
  defaultMaxLabelValueLength: 2048   # per_user_series_limit - ENFORCED
  defaultMaxSeriesPerRequest: 10000  # per_metric_series_limit - ENFORCED

# Selective Enforcement Configuration
# Enable cardinality limits AND ingestion rate limiting
enforcement:
  enabled: true
  # Cardinality limits - ENFORCED
  enforceMaxSeriesPerRequest: true   # per_user_series_limit
  enforceMaxSeriesPerMetric: true    # per_metric_series_limit
  enforceMaxLabelsPerSeries: true    # per_labels_per_series_limit
  # Rate limiting - ENABLED
  enforceSamplesPerSecond: true      # Enable ingestion rate limiting
  enforceBytesPerSecond: false       # No bytes rate limiting
  # Body size - DISABLED
  enforceMaxBodyBytes: false         # No body size enforcement

# Store configuration
store:
  backend: "redis"  # memory or redis - Use redis for shared state in production

# Logging configuration - Production (Optimized for performance)
log:
  level: "warn"  # Reduced from "info" to "warn" to reduce log overhead
  enableGRPCLogs: false  # Production: Disable gRPC logs for performance
  enableDetailedLogs: false  # Production: Disable detailed logs for performance

# Performance tuning - Production
performance:
  # Request processing optimization
  maxConcurrentRequests: 1000    # Increase concurrent request handling
  requestTimeout: "30s"          # Set explicit timeout for RLS processing
  bodyParseTimeout: "10s"        # Timeout for body parsing operations
  
  # Redis connection optimization
  redisPoolSize: 50              # Increase Redis connection pool
  redisMinIdleConns: 10          # Minimum idle connections
  redisMaxRetries: 3             # Redis retry attempts
  
  # Memory optimization
  enableMemoryOptimization: true # Enable memory-efficient processing
  maxRequestBodySize: "50MB"     # Maximum body size to process
  
  # Circuit breaker settings
  circuitBreakerEnabled: true    # Enable circuit breaker for Redis
  circuitBreakerThreshold: 5     # Number of failures before opening circuit
  circuitBreakerTimeout: "30s"   # Time to wait before trying again

# Deployment configuration
replicaCount: 1  # Reduced to 1 for resource constraints

image:
  repository: ghcr.io/akshaydubey29/mimir-rls
  tag: "latest-performance-optimized"  # Performance optimized version
  pullPolicy: IfNotPresent  # Production: Use IfNotPresent for efficiency

# Resource configuration - Production (Reduced for cluster capacity)
resources:
  limits:
    cpu: 1500m    # Reduced from 2000m
    memory: 1Gi   # Reduced from 2Gi
  requests:
    cpu: 500m     # Reduced from 750m
    memory: 512Mi # Reduced from 768Mi

# Security context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000
  capabilities:
    drop:
      - ALL

# Horizontal Pod Autoscaler (Conservative scaling)
hpa:
  enabled: true
  minReplicas: 1    # Reduced from 2
  maxReplicas: 3    # Reduced from 8
  targetCPUUtilizationPercentage: 80    # Increased from 75
  targetMemoryUtilizationPercentage: 80 # Increased from 75

# Pod Disruption Budget
pdb:
  enabled: true
  minAvailable: 1

# Service Account
serviceAccount:
  create: true
  annotations: {}

# Pod annotations - Production
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"
  prometheus.io/path: "/metrics"

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}

# Service Monitor for Prometheus - Production
serviceMonitor:
  enabled: false  # Disable ServiceMonitor for local testing
  scrapeTimeout: 10s
  labels: {}
  annotations: {}

# Redis configuration for shared state
redis:
  # Redis deployment mode
  mode: "external"  # Options: "sidecar" (local per pod) or "external" (shared instance)
  
  # External Redis configuration (when mode: "external")
  external:
    enabled: true  # Set to true to use external Redis
    address: "redis-shared-service.redis-shared.svc.cluster.local:6379"  # External Redis service address
    password: ""  # Redis password if required
    database: 0  # Redis database number
  
  # Sidecar Redis configuration (when mode: "sidecar")
  sidecar:
    enabled: false  # Set to false when using external Redis
    image:
      repository: redis
      tag: "7.2-alpine"
      pullPolicy: IfNotPresent
    resources:
      limits:
        cpu: 500m
        memory: 1Gi
      requests:
        cpu: 100m
        memory: 256Mi
    persistence:
      enabled: true  # Production: Enable persistence for data durability
      size: 10Gi
      storageClass: "standard"  # Production: Use standard storage class (rancher.io/local-path)
      # Alternative storage classes:
      # storageClass: "gp3"  # For AWS
      # storageClass: "fast-ssd"  # For GCP
      # storageClass: "managed-premium"  # For Azure
      # storageClass: ""  # Use default storage class if not specified
    securityContext:
      runAsNonRoot: true
      runAsUser: 999
      fsGroup: 999
    # Production Redis configuration
    config:
      maxmemory: "800mb"
      maxmemoryPolicy: "allkeys-lru"
      appendonly: "yes"
      save: ["900 1", "300 10", "60 10000"]
      timeout: 300
      tcpKeepalive: 300
      # Security settings
      protectedMode: "yes"
      # Performance settings
      tcpBacklog: 511
      databases: 16

# Image pull secrets
imagePullSecrets: []

# Envoy integration optimization
envoy:
  # ext_authz filter configuration
  extAuthz:
    timeout: "5s"                    # Increase timeout from default to 5s
    failureModeAllow: true           # Allow requests when RLS is unavailable
    includePeerCertificate: false    # Disable for performance
    includeTlsSession: false         # Disable for performance
    
    # Buffer settings for large requests
    bufferMaxBytes: "52428800"       # 50MB buffer for large requests
    bufferTimeout: "10s"             # Buffer timeout
    
    # Retry configuration
    retryOn: "connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes"
    numRetries: 2                    # Number of retries
    retryBackoffBaseInterval: "100ms" # Base retry interval
    
  # Rate limiting configuration
  rateLimit:
    timeout: "2s"                    # Rate limit timeout
    failureModeDeny: false           # Allow when rate limiter fails
    
  # Load balancing configuration
  loadBalancer:
    policy: "round_robin"            # Round-robin load balancing
    healthCheck:
      enabled: true
      interval: "10s"
      timeout: "2s"
      unhealthyThreshold: 3
      healthyThreshold: 2
