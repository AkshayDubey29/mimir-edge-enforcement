# RLS (Rate Limit Service) Values - Production Configuration
# Use this file for deploying RLS in production with optimized settings

# Service configuration
service:
  type: ClusterIP
  port: 8082  # Main service port (admin API)
  ports:
    extAuthz: 8080
    rateLimit: 8081
    admin: 8082
    metrics: 9090

# Tenant identification
tenantHeader: "X-Scope-OrgID"

# Limits configuration - Production
# SELECTIVE ENFORCEMENT: Only enforce cardinality limits (per_metric_series_limit and per_user_series_limit)
limits:
  maxRequestBytes: "10485760"  # 10 MiB - Increased for large Alloy payloads
  maxBodyBytes: 0              # 0 = Disabled - No body size enforcement
  failureModeAllow: true       # Production: Allow requests when parsing fails (with intelligent fallback)
  defaultSamplesPerSecond: 1000      # 1000 samples/sec - Enable rate limiting
  defaultBurstPercent: 10      # 10% burst allowance
  enforceBodyParsing: true     # Production: Enable body parsing for cardinality analysis
  defaultMaxLabelsPerSeries: 0       # per_user_series_limit - DISABLED (0 = no limit)
  defaultMaxLabelValueLength: 2048   # per_user_series_limit - ENFORCED
  defaultMaxSeriesPerRequest: 10000  # per_metric_series_limit - ENFORCED

# Selective Enforcement Configuration
# Enable cardinality limits AND ingestion rate limiting
enforcement:
  enabled: true
  # Cardinality limits - ENFORCED
  enforceMaxSeriesPerRequest: true   # per_user_series_limit
  enforceMaxSeriesPerMetric: true    # per_metric_series_limit
  enforceMaxLabelsPerSeries: false   # per_labels_per_series_limit - DISABLED
  # Rate limiting - ENABLED
  enforceSamplesPerSecond: true      # Enable ingestion rate limiting
  enforceBytesPerSecond: false       # No bytes rate limiting
  # Body size - DISABLED
  enforceMaxBodyBytes: false         # No body size enforcement

# Store configuration
store:
  backend: "redis"  # Required for multi-pod deployment with shared state

# Logging configuration - PRODUCTION OPTIMIZED
log:
  level: "warn"  # Minimal logging for maximum performance
  enableGRPCLogs: false  # Disable gRPC logs for performance
  enableDetailedLogs: false  # Disable detailed logs for performance

# Performance tuning - ULTRA OPTIMIZED
performance:
  # Request processing optimization
  maxConcurrentRequests: 5000    # Ultra-high concurrent request handling
  requestTimeout: "5s"           # Ultra-fast timeout for RLS processing
  bodyParseTimeout: "2s"         # Ultra-fast timeout for body parsing
  
  # Redis connection optimization (Ultra-optimized for performance)
  redisPoolSize: 100             # Large pool for high throughput
  redisMinIdleConns: 20          # More idle connections for faster response
  redisMaxRetries: 0             # No retries for ultra-fast fail
  redisConnectTimeout: "500ms"   # Ultra-fast connection timeout
  redisReadTimeout: "1s"         # Ultra-fast read timeout
  redisWriteTimeout: "1s"        # Ultra-fast write timeout
  
  # Memory optimization
  enableMemoryOptimization: true # Enable memory-efficient processing
  maxRequestBodySize: "10MB"     # Reduced for faster processing
  enableRequestPooling: true     # Enable request object pooling
  enableMetricsOptimization: true # Optimize metrics collection
  
  # Circuit breaker settings (Ultra-fast)
  circuitBreakerEnabled: false   # Disable circuit breaker for speed
  circuitBreakerThreshold: 1     # Single failure threshold
  circuitBreakerTimeout: "1s"    # Ultra-fast recovery

# Deployment configuration
replicaCount: 1  # Reduced to 1 for resource constraints

image:
  repository: ghcr.io/akshaydubey29/mimir-rls
  tag: "latest-ultra-fast"  # Ultra-fast version with aggressive performance optimizations
  pullPolicy: IfNotPresent  # Production: Use IfNotPresent for efficiency

# Resource configuration - ULTRA OPTIMIZED
resources:
  limits:
    cpu: 4000m    # High CPU for maximum performance
    memory: 4Gi   # High memory for caching and processing
  requests:
    cpu: 2000m    # High CPU requests for performance
    memory: 2Gi   # High memory requests for caching

# Security context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000
  capabilities:
    drop:
      - ALL

# Horizontal Pod Autoscaler (ULTRA OPTIMIZED)
hpa:
  enabled: true
  minReplicas: 3    # Higher minimum for better performance
  maxReplicas: 10   # Higher maximum for scaling
  targetCPUUtilizationPercentage: 70    # Lower threshold for faster scaling
  targetMemoryUtilizationPercentage: 70 # Lower threshold for faster scaling

# Pod Disruption Budget
pdb:
  enabled: true
  minAvailable: 1

# Service Account
serviceAccount:
  create: true
  annotations: {}

# Pod annotations - Production
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"
  prometheus.io/path: "/metrics"

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}

# Service Monitor for Prometheus - Production
serviceMonitor:
  enabled: false  # Disable ServiceMonitor for local testing
  scrapeTimeout: 10s
  labels: {}
  annotations: {}

# Redis configuration for shared state
redis:
  # Redis deployment mode
  mode: "external"  # Options: "sidecar" (local per pod) or "external" (shared instance)
  
  # External Redis configuration (when mode: "external")
  external:
    enabled: true  # Set to true to use external Redis
    address: "redis-shared-service.redis-shared.svc.cluster.local:6379"  # External Redis service address
    password: ""  # Redis password if required
    database: 0  # Redis database number
  
  # Sidecar Redis configuration (when mode: "sidecar")
  sidecar:
    enabled: false  # Set to false when using external Redis
    image:
      repository: redis
      tag: "7.2-alpine"
      pullPolicy: IfNotPresent
    resources:
      limits:
        cpu: 500m
        memory: 1Gi
      requests:
        cpu: 100m
        memory: 256Mi
    persistence:
      enabled: true  # Production: Enable persistence for data durability
      size: 10Gi
      storageClass: "standard"  # Production: Use standard storage class (rancher.io/local-path)
      # Alternative storage classes:
      # storageClass: "gp3"  # For AWS
      # storageClass: "fast-ssd"  # For GCP
      # storageClass: "managed-premium"  # For Azure
      # storageClass: ""  # Use default storage class if not specified
    securityContext:
      runAsNonRoot: true
      runAsUser: 999
      fsGroup: 999
    # Production Redis configuration
    config:
      maxmemory: "800mb"
      maxmemoryPolicy: "allkeys-lru"
      appendonly: "yes"
      save: ["900 1", "300 10", "60 10000"]
      timeout: 300
      tcpKeepalive: 300
      # Security settings
      protectedMode: "yes"
      # Performance settings
      tcpBacklog: 511
      databases: 16

# Image pull secrets
imagePullSecrets: []
