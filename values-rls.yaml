# RLS (Rate Limit Service) Values - Production Configuration
# Use this file for deploying RLS in production with optimized settings

# Service configuration
service:
  type: ClusterIP
  port: 8082  # Main service port (admin API)
  ports:
    extAuthz: 8080
    rateLimit: 8081
    admin: 8082
    metrics: 9090

# Tenant identification
tenantHeader: "X-Scope-OrgID"

# Limits configuration - Production Optimized
limits:
  maxRequestBytes: "10485760"  # 10 MiB - Increased for large payloads
  maxBodyBytes: 1048576        # 1 MiB - Reasonable body size limit
  failureModeAllow: true       # Production: Allow requests when parsing fails
  defaultSamplesPerSecond: 1000      # 1000 samples/sec - Enable rate limiting
  defaultBurstPercent: 20      # 20% burst allowance
  enforceBodyParsing: true     # Production: Enable body parsing for cardinality analysis
  defaultMaxLabelsPerSeries: 10      # Reasonable label limit
  defaultMaxLabelValueLength: 2048   # Reasonable label value length
  defaultMaxSeriesPerRequest: 10000  # Reasonable series per request limit

# Enforcement Configuration - Production Ready
enforcement:
  enabled: true
  # Cardinality limits - ENABLED
  enforceMaxSeriesPerRequest: true   # per_user_series_limit
  enforceMaxSeriesPerMetric: true    # per_metric_series_limit
  enforceMaxLabelsPerSeries: true    # per_labels_per_series_limit
  # Rate limiting - ENABLED
  enforceSamplesPerSecond: true      # Enable ingestion rate limiting
  enforceBytesPerSecond: false       # No bytes rate limiting (focus on samples)
  # Body size - ENABLED
  enforceMaxBodyBytes: true          # Enable body size enforcement

# Store configuration
store:
  backend: "redis"  # Required for multi-pod deployment with shared state

# Mimir configuration for direct integration
mimir:
  host: "mock-mimir-distributor.mimir.svc.cluster.local"
  port: "8080"

# Logging configuration - PRODUCTION OPTIMIZED
log:
  level: "info"  # Production logging level
  enableGRPCLogs: false  # Disable gRPC logs for performance
  enableDetailedLogs: false  # Disable detailed logs for performance

# Performance tuning - PRODUCTION OPTIMIZED
performance:
  # Request processing optimization
  maxConcurrentRequests: 2000    # High concurrent request handling
  requestTimeout: "10s"          # Reasonable timeout for RLS processing
  bodyParseTimeout: "5s"         # Reasonable timeout for body parsing
  
  # Redis connection optimization (Production optimized)
  redisPoolSize: 50              # Reasonable pool size for production
  redisMinIdleConns: 10          # Idle connections for faster response
  redisMaxRetries: 3             # Retries for reliability
  redisConnectTimeout: "1s"      # Connection timeout
  redisReadTimeout: "2s"         # Read timeout
  redisWriteTimeout: "2s"        # Write timeout
  
  # Memory optimization
  enableMemoryOptimization: true # Enable memory-efficient processing
  maxRequestBodySize: "10MB"     # Maximum request body size
  enableRequestPooling: true     # Enable request object pooling
  enableMetricsOptimization: true # Optimize metrics collection
  
  # Circuit breaker settings (Production)
  circuitBreakerEnabled: true    # Enable circuit breaker for reliability
  circuitBreakerThreshold: 5     # Failure threshold
  circuitBreakerTimeout: "30s"   # Recovery timeout

# Deployment configuration
replicaCount: 3  # Production: Multiple replicas for high availability

image:
  repository: ghcr.io/akshaydubey29/mimir-rls
  tag: "latest"  # Latest version with scientific notation support and multi-arch builds
  pullPolicy: IfNotPresent  # Production: Use IfNotPresent for efficiency

# Resource configuration - TEMPORARILY REDUCED FOR TESTING
resources:
  limits:
    cpu: 1000m    # Reduced for testing
    memory: 1Gi   # Reduced for testing
  requests:
    cpu: 250m     # Reduced for testing
    memory: 512Mi # Reduced for testing

# Security context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000
  capabilities:
    drop:
      - ALL

# Horizontal Pod Autoscaler (PRODUCTION OPTIMIZED)
hpa:
  enabled: true
  minReplicas: 3    # Minimum replicas for high availability
  maxReplicas: 10   # Maximum replicas for scaling
  targetCPUUtilizationPercentage: 70    # CPU threshold for scaling
  targetMemoryUtilizationPercentage: 70 # Memory threshold for scaling

# Pod Disruption Budget
pdb:
  enabled: true
  minAvailable: 2  # Ensure at least 2 pods are always available

# Service Account
serviceAccount:
  create: true
  annotations: {}

# Pod annotations - Production
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"
  prometheus.io/path: "/metrics"

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity - Production ready
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - mimir-rls
        topologyKey: kubernetes.io/hostname

# Service Monitor for Prometheus - Production
serviceMonitor:
  enabled: false  # Disable ServiceMonitor to avoid CRD issues
  scrapeTimeout: 10s
  labels: {}
  annotations: {}

# Redis configuration for shared state
redis:
  # Redis deployment mode
  mode: "external"  # Use external Redis for production
  
  # External Redis configuration (when mode: "external")
  external:
    enabled: true  # Use external Redis
    address: "redis-shared-service.redis-shared.svc.cluster.local:6379"  # External Redis service
    password: ""  # Redis password if required
    database: 0  # Redis database number
  
  # Sidecar Redis configuration (when mode: "sidecar")
  sidecar:
    enabled: false  # Disabled when using external Redis
    image:
      repository: redis
      tag: "7.2-alpine"
      pullPolicy: IfNotPresent
    resources:
      limits:
        cpu: 500m
        memory: 1Gi
      requests:
        cpu: 100m
        memory: 256Mi
    persistence:
      enabled: true  # Production: Enable persistence for data durability
      size: 10Gi
      storageClass: "standard"  # Production: Use standard storage class
    securityContext:
      runAsNonRoot: true
      runAsUser: 999
      fsGroup: 999
    # Production Redis configuration
    config:
      maxmemory: "800mb"
      maxmemoryPolicy: "allkeys-lru"
      appendonly: "yes"
      save: ["900 1", "300 10", "60 10000"]
      timeout: 300
      tcpKeepalive: 300
      # Security settings
      protectedMode: "yes"
      # Performance settings
      tcpBacklog: 511
      databases: 16

# Image pull secrets
imagePullSecrets: []

# Liveness and readiness probes - Production
livenessProbe:
  httpGet:
    path: /readyz
    port: admin
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /readyz
    port: admin
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

# Startup probe
startupProbe:
  httpGet:
    path: /readyz
    port: admin
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 30
